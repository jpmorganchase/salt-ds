---
title:
  $ref: ./#/title
layout: DetailComponent
sidebar:
  exclude: true
data:
  $ref: ./#/data
---

<LivePreviewControls>
<LivePreview componentName="multiline-input" exampleName="Primary" >

### Primary

Values entered into the Multiline Input are set to wrap based on the width of the component. Initially, the component is empty. Once it has focus it accepts text across multiple lines. By default, the component presents three rows of text at a time.

If entering more than three rows of text, the user can review the entered value using keyboard controls.

- Multiline Input has two variants: "primary" and "secondary". The primary variant is default. The choice between primary and secondary variants should be considered alongside the background color it sits upon. For recommendations on variant choice, see the [Forms pattern](/salt/patterns/forms).

</LivePreview>

<LivePreview componentName="multiline-input" exampleName="Secondary">

### Secondary

Secondary variant is an effective option if included as part of a data-dense or compact interface, or within a form with multiple columns or sections.

The choice between primary and secondary variants should be considered in the context of the background color it sits upon.

- For recommendations on variant choice, see the [Forms pattern](/salt/patterns/forms).

</LivePreview>
<LivePreview componentName="multiline-input" exampleName="Disabled">

### Disabled

Multiline Input can be set to a disabled state, with no resultant action when the user interacts with it. Showing it in a disabled state means the user is aware of its presence or an entered value but is not able to edit it.

</LivePreview>
<LivePreview componentName="multiline-input" exampleName="Readonly">

### Read-only

Multiline Input can be set to a read-only state. The entered text cannot be edited in this state, but it can be highlighted and copied.

Use the read-only state when the value is necessary for the user’s flow or current task but cannot be edited, for instance when a user's permissions are restricted.

When setting Multiline Input to a read-only state, ensure to also disable any nested interactive adornments, such as buttons.

</LivePreview>
<LivePreview componentName="multiline-input" exampleName="Bordered">

### Bordered

To style Multiline Input with a full border set `bordered={true}`.

- We recommend this styling when the field uses the same fill color as the background (i.e., a primary fill color on a primary background).

</LivePreview>
<LivePreview componentName="multiline-input" exampleName="NumberOfRows">

### Number Of Rows

The Multiline Input shows three rows of text by default. This can be adjusted, using the `rows` prop, to provide a larger input allowing the user to review more of the entered text without the need for further interactions. This example demonstrates a Multiline Input customized to show four rows.

Set the number of rows to best reflect the context that your Multiline Input is being displayed, and how much user input would be expected in that context.

</LivePreview>
<LivePreview componentName="multiline-input" exampleName="CharacterCount">

### Character Count

You can add a character count as a label using `endAdornment` props. The example demonstrates the expected behaviour when the count is exceeded, with the field dynamically displaying an error state and the count continuing to display the number of characters over the limit.

If the user goes over the character count limit, display an error state and change the Label to `primary` variant with a weight of ‘strong’.

</LivePreview>
<LivePreview componentName="multiline-input" exampleName="ValidationStatus">

### Validation Status

Indicate validation state by setting the `validationStatus` prop.

- Use the “error” state when you want to alert the user to a critical issue related to the input. This issue, which will jeopardize completion of the task, usually requires action from the user to resolve the error.

- Display the “warning” state when you need to alert the user of a non-critical issue—that won’t prevent the user from continuing with the task, but may cause errors if it’s not addressed.

</LivePreview>
<LivePreview componentName="multiline-input" exampleName="Placeholder">

### Placeholder

A placeholder can be used to prompt user input if no default value is provided.

Placeholder text should never be used to provide the user with contextual help since it will be removed when the user starts typing and does not meet minimum contrast requirements. Doing so is a WCAG failure. Instead, use helper text beneath the input to provide instructions, and reserve the placeholder text to support the help message, or provide an example of the input.

More information can be found [here](https://www.w3.org/WAI/tutorials/forms/instructions/)

</LivePreview>
<LivePreview componentName="multiline-input" exampleName="StaticAdornments" >

### Static Adornments

You can add custom adornments at the beginning or end of the Multiline Input area using the `startAdornment` and `endAdornment` props.

Start adornments are typically used to describe the purpose of the field (eg., a phone number input, or a currency), whereas end adornments are typically used to indicate a reveal of more information (eg., using an arrow icon) or to trigger a new UI (such as a date picker).

Salt [Text](../text) and [Icons](/salt/foundations/iconography) can be used to add Salt styled alphanumeric text or symbols as adornments. Multiple start or end adornments should be wrapped in a parent container and passed to the respective prop as a single fragment. Adornments can be dynamic, with their value depending on the current state.

</LivePreview>
<LivePreview componentName="multiline-input" exampleName="ButtonAdornment" >

### Button Adornments

You can use a [Button](../button) at the beginning or end of the Multiline Input using the `startAdornment` and `endAdornment` props. Buttons can allow for custom interactivity within the Multiline Input area itself, or elsewhere in the app via the Multiline Input.

If the containing Multiline Input is disabled or read-only, ensure your interactive buttons match that state.

</LivePreview>
</LivePreviewControls>
