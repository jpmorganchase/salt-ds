{
  "version": 3,
  "sources": ["../utils/src/logging.ts", "../data-remote/src/remote-websocket-connection.ts", "../utils/src/filter-utils.ts", "../../node_modules/d3-array/src/ascending.js", "../../node_modules/d3-array/src/bisector.js", "../../node_modules/d3-array/src/number.js", "../../node_modules/d3-array/src/bisect.js", "../../node_modules/d3-array/src/count.js", "../../node_modules/d3-array/src/extent.js", "../../node_modules/d3-array/src/identity.js", "../../node_modules/d3-array/src/array.js", "../../node_modules/d3-array/src/constant.js", "../../node_modules/d3-array/src/ticks.js", "../../node_modules/d3-array/src/nice.js", "../../node_modules/d3-array/src/threshold/sturges.js", "../../node_modules/d3-array/src/bin.js", "../utils/src/event-emitter.ts", "../data-store/src/table.js", "../data-store/src/selection-model.js", "../utils/src/input-utils.ts", "../utils/src/array-utils.ts", "../utils/src/constants.ts", "../utils/src/column-utils.ts", "../utils/src/range-utils.ts", "../utils/src/row-utils.ts", "../data-store/src/sort.js", "../data-store/src/group-utils.js", "../data-store/src/range-utils.js", "../data-store/src/rowset/rowSet.js", "../data-store/src/group-iterator.js", "../data-store/src/rowset/group-rowset.js", "../data-store/src/update-queue.js", "../data-store/src/data-store.js", "../data-store/src/worker-table.js", "../data-store/src/data-store-utils.js", "../data-store/src/data-store-connection.js", "../data-remote/src/test-data-collection.js", "../data-remote/src/servers/vuu/messages.ts", "../data-remote/src/servers/vuu/keyset.ts", "../data-remote/src/servers/vuu/buffer-range.ts", "../data-remote/src/servers/vuu/array-backed-moving-window.ts", "../data-remote/src/servers/vuu/new-viewport.js", "../data-remote/src/servers/vuu/rpc-services.js", "../data-remote/src/servers/vuu/new-server-proxy.ts", "src/index.js"],
  "sourcesContent": ["export const logColor = {\n  plain: 'color: black; font-weight: normal',\n  blue: 'color: blue; font-weight: bold',\n  brown: 'color: brown; font-weight: bold',\n  green: 'color: green; font-weight: bold'\n};\n\nconst { plain } = logColor;\n\nexport const createLogger = (source: string, labelColor: string = plain, msgColor: string = plain) => ({\n  log: (msg: string, args: any = '') =>\n    console.log(`[${Date.now()}]%c[${source}] %c${msg}`, labelColor, msgColor, args),\n  warn: (msg: string) => console.warn(`[${source}] ${msg}`)\n});\n", "import { createLogger, logColor } from '@vuu-ui/utils/src/logging';\n\n// TEST_DATA_COLLECTION\n// import { saveTestData } from './test-data-collection';\n\nconst logger = createLogger('WebsocketConnection', logColor.brown);\n\nconst connectionAttempts = {};\n\nconst setWebsocket = Symbol('setWebsocket');\nconst connectionCallback = Symbol('connectionCallback');\n\nexport default async function connect(connectionString, callback) {\n  return makeConnection(connectionString, (msg) => {\n    const { type } = msg;\n    if (type === 'HB') {\n      console.log(`swallowing HB in WebsocketConnection`);\n    } else if (type === 'Welcome') {\n      // Note: we are actually resolving the connection before we get this session message\n      logger.log(`Session established clientId: ${msg.clientId}`);\n    } else {\n      callback(msg);\n    }\n  });\n}\n\nasync function reconnect(connection) {\n  makeConnection(connection.url, connection[connectionCallback], connection);\n}\n\nasync function makeConnection(url, callback, connection) {\n  const connectionStatus =\n    connectionAttempts[url] ||\n    (connectionAttempts[url] = {\n      attemptsRemaining: 5,\n      status: 'disconnected'\n    });\n\n  try {\n    callback({ type: 'connection-status', status: 'connecting' });\n    const reconnecting = typeof connection !== 'undefined';\n    const ws = await createWebsocket(url);\n\n    console.log(\n      `%c\u26A1 %c${url}`,\n      'font-size: 24px;color: green;font-weight: bold;',\n      'color:green; font-size: 14px;'\n    );\n\n    if (reconnecting) {\n      connection[setWebsocket](ws);\n    } else {\n      connection = new Connection(ws, url, callback);\n    }\n\n    const status = reconnecting ? 'reconnected' : 'connected';\n\n    callback({ type: 'connection-status', status });\n\n    connection.status = status;\n\n    return connection;\n  } catch (evt) {\n    const retry = --connectionStatus.attemptsRemaining > 0;\n    callback({\n      type: 'connection-status',\n      status: 'disconnected',\n      reason: 'failed to connect',\n      retry\n    });\n    if (retry) {\n      return makeConnectionIn(url, callback, connection, 10000);\n    }\n  }\n}\n\nconst makeConnectionIn = (url, callback, connection, delay) =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(makeConnection(url, callback, connection));\n    }, delay);\n  });\n\nconst createWebsocket = (connectionString) =>\n  new Promise((resolve, reject) => {\n    //TODO add timeout\n    const ws = new WebSocket('ws://' + connectionString);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = (evt) => reject(evt);\n  });\n\nclass Connection {\n  constructor(ws, url, callback) {\n    this.url = url;\n    this[connectionCallback] = callback;\n    this[setWebsocket](ws);\n    this.status = 'ready';\n    this.requiresAuthentication = true;\n    this.requiresLogin = true;\n  }\n\n  reconnect() {\n    reconnect(this);\n  }\n\n  [setWebsocket](ws) {\n    const callback = this[connectionCallback];\n\n    ws.onmessage = (evt) => {\n      // TEST DATA COLLECTION\n      // saveTestData(evt.data, 'server');\n      const message = JSON.parse(evt.data);\n      // onsole.log(`%c<<< [${new Date().toISOString().slice(11,23)}]  (WebSocket) ${message.type || JSON.stringify(message)}`,'color:white;background-color:blue;font-weight:bold;');\n      callback(message);\n    };\n\n    ws.onerror = () => {\n      console.log(\n        `%c\u26A1 %c${this.url}`,\n        'font-size: 24px;color: red;font-weight: bold;',\n        'color:red; font-size: 14px;'\n      );\n      callback({\n        type: 'connection-status',\n        status: 'disconnected',\n        reason: 'error'\n      });\n      if (this.status !== 'closed') {\n        reconnect(this);\n        this.send = queue;\n      }\n    };\n\n    ws.onclose = () => {\n      console.log(\n        `%c\u26A1 %c${this.url}`,\n        'font-size: 24px;color: orange;font-weight: bold;',\n        'color:orange; font-size: 14px;'\n      );\n      callback({\n        type: 'connection-status',\n        status: 'disconnected',\n        reason: 'close'\n      });\n      if (this.status !== 'closed') {\n        reconnect(this);\n        this.send = queue;\n      }\n    };\n\n    const send = (msg) => {\n      // onsole.log(`%c>>>  (WebSocket) ${JSON.stringify(msg)}`,'color:blue;font-weight:bold;');\n      ws.send(JSON.stringify(msg));\n    };\n\n    const warn = (msg) => {\n      logger.log(`Message cannot be sent, socket closed: ${msg.type}`);\n    };\n\n    const queue = (msg) => {\n      console.log(`queuing message ${JSON.stringify(msg)} until websocket reconnected`);\n    };\n\n    this.send = send;\n\n    this.close = () => {\n      console.log('[Connection] close websocket');\n      this.status = 'closed';\n      ws.close();\n      this.send = warn;\n    };\n  }\n}\n", "import { Column, ColumnMap } from './column-utils';\nimport { Row } from './row-utils';\n\nexport const AND = 'and';\nexport const EQUALS = '=';\nexport const NOT_EQUALS = '!=';\nexport const GREATER_THAN = '>';\nexport const LESS_THAN = '<';\nexport const OR = 'or';\nexport const STARTS_WITH = 'starts';\nexport const ENDS_WITH = 'ends';\nexport const IN = 'in';\n\nexport type FilterType =\n  | 'and'\n  | '='\n  | '>'\n  | '>='\n  | 'in'\n  | '<='\n  | '<'\n  | 'NOT_IN'\n  | 'NOT_SW'\n  | 'or'\n  | 'SW';\n\nexport const SET_FILTER_DATA_COLUMNS = [\n  { name: 'name', flex: 1 },\n  { name: 'count', width: 40, type: 'number' },\n  { name: 'totalCount', width: 40, type: 'number' }\n];\n\nexport const BIN_FILTER_DATA_COLUMNS = [\n  { name: 'bin' },\n  { name: 'count' },\n  { name: 'bin-lo' },\n  { name: 'bin-hi' }\n];\n\nexport default function filterRows(rows: Row[], columnMap: ColumnMap, filter: Filter) {\n  return applyFilter(rows, functor(columnMap, filter));\n}\n\nexport const filterClauses = (filter, clauses = []) => {\n  if (filter) {\n    const { column, op, value, values, filters } = filter;\n    if (op === 'or' || op === 'and') {\n      filters.forEach((f) => clauses.push(...filterClauses(f)));\n    } else {\n      clauses.push({ column, op, value: value ?? values?.join(',') });\n    }\n    return clauses;\n  } else {\n    return clauses;\n  }\n};\n\nconst DEFAULT_ADD_FILTER_OPTS = {\n  combineWith: AND\n};\n\nexport function addFilter(\n  existingFilter: Filter | null,\n  filter: Filter | null,\n  { combineWith = AND } = DEFAULT_ADD_FILTER_OPTS\n) {\n  if (includesNoValues(filter)) {\n    const { column } = filter;\n    existingFilter = removeFilterForColumn(existingFilter, { name: column });\n  } else if (includesAllValues(filter)) {\n    // A filter that returns all values is a way to remove filtering for this column\n    return removeFilterForColumn(existingFilter, { name: filter.column });\n  }\n\n  if (!existingFilter) {\n    return filter;\n  } else if (!filter) {\n    return existingFilter;\n  }\n\n  if (existingFilter.op === AND && filter.op === AND) {\n    return { type: AND, filters: combine(existingFilter.filters, filter.filters) };\n  } else if (existingFilter.op === AND) {\n    const filters = replaceOrInsert(existingFilter.filters, filter);\n    return filters.length > 1 ? { op: AND, filters } : filters[0];\n  } else if (filter.op === AND) {\n    return { op: AND, filters: filter.filters.concat(existingFilter) };\n  } else if (filterEquals(existingFilter, filter, true)) {\n    return filter;\n  } else if (sameColumn(existingFilter, filter)) {\n    return merge(existingFilter, filter);\n  } else {\n    return { op: AND, filters: [existingFilter, filter] };\n  }\n}\n\nexport function includesNoValues(filter?: Filter | null): boolean {\n  // TODO make sure we catch all cases...\n  if (!filter) {\n    return false;\n  }\n  if (isInFilter(filter) && filter.values.length === 0) {\n    return true;\n  }\n  return isAndFilter(filter) && filter.filters!.some((f) => includesNoValues(f));\n}\n\nexport function isColumnGroup(column: Column | ColumnGroup): column is ColumnGroup {\n  return column.isGroup === true;\n}\n\nexport function getFilterColumn(column: Column | ColumnGroup) {\n  return isColumnGroup(column) ? column.columns[0] : column;\n}\n\n// TODO types for different types of filters\n\ninterface CommonFilter {\n  colName?: string;\n  otherColFilters?: Filter[];\n  // values?: any[];\n  mode?: any;\n  value?: any;\n  values?: any;\n  op?: 'or' | 'and';\n  column?: string;\n  filters?: Filter[];\n}\n\ninterface CombinedFilter extends CommonFilter {\n  type: 'and' | 'or'; // TODO any other types?\n  filters: Filter[];\n}\n\n// 'and' filter must have 'filters'\nexport interface AndFilter extends CombinedFilter {\n  type: 'and';\n}\n\nexport function createAndFilter(filters: Filter[]): AndFilter {\n  return {\n    type: 'and',\n    filters\n  };\n}\n\n// 'or' filter must have 'filters'\nexport interface OrFilter extends CombinedFilter {\n  type: 'or';\n}\n\nexport interface InFilter extends CommonFilter {\n  type: 'in';\n  values: any[];\n}\n\nexport interface NotInFilter extends CommonFilter {\n  type: 'NOT_IN';\n  values: any[];\n}\n\nexport interface OtherFilter extends CommonFilter {\n  type: FilterType;\n  values?: any[];\n}\n\nexport type Filter = AndFilter | OrFilter | InFilter | NotInFilter | OtherFilter;\n\nexport type RowFilterFn = (row: Row) => boolean;\n\nexport function functor(columnMap: ColumnMap, filter: Filter): RowFilterFn {\n  //TODO convert filter to include colIdx rather than colName, so we don't have to pass cols\n  switch (filter.type) {\n    case IN:\n      return testInclude(columnMap, filter);\n    case EQUALS:\n      return testEQ(columnMap, filter);\n    case NOT_EQUALS:\n      return !testEQ(columnMap, filter);\n    case GREATER_THAN:\n      return testGT(columnMap, filter);\n    case LESS_THAN:\n      return testLT(columnMap, filter);\n    case STARTS_WITH:\n      return testSW(columnMap, filter);\n    case AND:\n      return testAND(columnMap, filter as AndFilter);\n    case OR:\n      return testOR(columnMap, filter as OrFilter);\n    default:\n      // TODO\n      // console.log(`unrecognized filter type ${filter.type}`);\n      return () => true;\n  }\n}\n\nfunction applyFilter(rows: Row[], filter: RowFilterFn) {\n  const results = [];\n  for (let i = 0; i < rows.length; i++) {\n    if (filter(rows[i])) {\n      results.push(rows[i]);\n    }\n  }\n  return results;\n}\n\nfunction testAND(cols: ColumnMap, f: AndFilter) {\n  const filters = f.filters.map((f1) => functor(cols, f1));\n  return (row: Row) => filters.every((fn) => fn(row));\n}\n\nfunction testOR(cols: ColumnMap, f: OrFilter) {\n  const filters = f.filters.map((f1) => functor(cols, f1));\n  return (row: Row) => filters.some((fn) => fn(row));\n}\n\nfunction testSW(cols: ColumnMap, f: Filter, inversed = false) {\n  const value = f.value.toLowerCase();\n  return inversed\n    ? (row: Row) => row[cols[f.colName!]].toLowerCase().indexOf(value) !== 0\n    : (row: Row) => row[cols[f.colName!]].toLowerCase().indexOf(value) === 0;\n}\n\nfunction testGT(cols: ColumnMap, f: Filter) {\n  return (row: Row) => row[cols[f.colName!]] > f.value;\n}\n\nfunction testLT(cols: ColumnMap, f: Filter) {\n  return (row) => row[cols[f.colName]] < f.value;\n}\n\nfunction testInclude(cols: ColumnMap, f: Filter) {\n  // eslint-disable-next-line eqeqeq\n  return (row: Row) => f.values.findIndex((val: any) => val == row[cols[f.colName!]]) !== -1;\n}\n\nfunction testEQ(cols, f) {\n  return (row) => row[cols[f.colName]] === f.value;\n}\n\nexport function shouldShowFilter(filterColumnName: string, column: Column): boolean {\n  const filterColumn = getFilterColumn(column);\n  if (isColumnGroup(filterColumn)) {\n    return filterColumn.columns.some((col) => col.name === filterColumnName);\n  } else {\n    return filterColumnName === filterColumn.name;\n  }\n}\n\nfunction includesAllValues(filter?: Filter | null): boolean {\n  if (!filter) {\n    return false;\n  } else if (filter.type === STARTS_WITH && filter.value === '') {\n    return true;\n  }\n  return filter.type === STARTS_WITH && filter.value === '';\n}\n\n// does f2 only narrow the resultset from f1\nexport function extendsFilter(f1: Filter | null = null, f2: Filter | null = null): boolean {\n  // ignore filters which are identical\n  // include or exclude filters which add values\n  if (f2 === null) {\n    return false;\n  } else if (f1 === null) {\n    return true;\n  }\n  if (f1.colName && f1.colName === f2.colName) {\n    if (f1.type === f2.type) {\n      switch (f1.type) {\n        case IN:\n          return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n        case STARTS_WITH:\n          return f2.value.length > f1.value.length && f2.value.indexOf(f1.value) === 0;\n        // more cases here such as GT,LT\n        default:\n      }\n    }\n  } else if (f1.colName && f2.colName) {\n    // different columns,always false\n    return false;\n  } else if (isAndFilter(f2) && extendsFilters(f1 as CombinedFilter, f2)) {\n    return true;\n  }\n\n  // safe option is to assume false, causing filter to be re-applied to base data\n  return false;\n}\n\nconst byColName = (a: Filter, b: Filter) =>\n  a.colName === b.colName ? 0 : a.colName && b.colName && a.colName < b.colName ? -1 : 1;\n\nfunction extendsFilters(f1: CombinedFilter, f2: CombinedFilter) {\n  if (f1.colName) {\n    const matchingFilter = f2.filters.find((f) => f.colName === f1.colName);\n    return filterEquals(matchingFilter, f1, true);\n  } else if (f1.filters.length === f2.filters.length) {\n    // if the only differences are extra values in an excludes filter or fewer values in an includes filter\n    // then we are still extending the filter (i.e. narrowing the resultset)\n    const a = f1.filters.sort(byColName);\n    const b = f2.filters.slice().sort(byColName);\n\n    for (let i = 0; i < a.length; i++) {\n      if (!filterEquals(a[i], b[i], true) && !filterExtends(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (f2.filters.length > f1.filters.length) {\n    return f1.filters.every((filter1) => {\n      const filter2 = f2.filters.find((f) => f.colName === filter1.colName);\n      return filterEquals(filter1, filter2, true); // could also allow f2 extends f1\n    });\n  }\n}\n\n// If we add an IN filter and there is an existing NOT_IN, we would always expect the IN\n// values to exist in the NOT_IN set (as long as user interaction is driving the filtering)\nfunction replaceOrInsert(filters, filter) {\n  // const { type, column, values } = filter;\n  // if (type === IN) {\n  //   let idx = filters.findIndex((f) => f.type === EQUALS && f.column === column);\n  //   if (idx !== -1) {\n  //     const { values: existingValues } = filters[idx];\n  //     if (values.every((value) => existingValues.indexOf(value) !== -1)) {\n  //       if (values.length === existingValues.length) {\n  //         // we simply remove the existing 'other' filter ...\n  //         return filters.filter((f, i) => i !== idx);\n  //       } else {\n  //         // ... or strip the matching values from the 'other' filter values\n  //         let newValues = existingValues.filter((value) => !values.includes(value));\n  //         return filters.map((filter, i) =>\n  //           i === idx ? { ...filter, values: newValues } : filter\n  //         );\n  //       }\n  //     } else if (values.some((value) => existingValues.indexOf(value) !== -1)) {\n  //       console.log(`partial overlap between IN and NOT_IN`);\n  //     }\n  //   } else {\n  //     idx = filters.findIndex((f) => f.type === type && f.colName === filter.colName);\n  //     if (idx !== -1) {\n  //       return filters.map((f, i) => (i === idx ? merge(f, filter) : f));\n  //     }\n  //   }\n  // }\n\n  return filters.concat(filter);\n}\n\nfunction merge(f1: Filter, f2: Filter): Filter | null {\n  const { type: t1 } = f1;\n  const { type: t2 } = f2;\n  const sameType = t1 === t2 ? t1 : '';\n\n  if (includesNoValues(f2)) {\n    return f2;\n  } else if (sameType === IN) {\n    return {\n      ...f1,\n      values: f1.values.concat(f2.values.filter((v: any) => !f1.values.includes(v)))\n    };\n  } else if (sameType === STARTS_WITH) {\n    return {\n      type: OR,\n      filters: [f1, f2]\n    };\n  }\n\n  return f2;\n}\n\nfunction combine(existingFilters: Filter[], replacementFilters: Filter[]) {\n  // TODO need a safer REGEX here\n  function equivalentType({ type: t1 }: Filter, { type: t2 }: Filter) {\n    return t1 === t2 || t1[0] === t2[0];\n  }\n\n  const replaces = (existingFilter: Filter, replacementFilter: Filter) => {\n    return (\n      existingFilter.colName === replacementFilter.colName &&\n      equivalentType(existingFilter, replacementFilter)\n    );\n  };\n\n  const stillApplicable = (existingFilter: Filter) =>\n    replacementFilters.some((replacementFilter) => replaces(existingFilter, replacementFilter)) ===\n    false;\n\n  return existingFilters.filter(stillApplicable).concat(replacementFilters);\n}\n\nexport function removeColumnFromFilter(column: Column, filter: Filter) {\n  // RODO need to recurse into nested and/or\n  const { op, filters } = filter;\n  if (op === 'and' || op === 'or') {\n    const [clause1, clause2] = filters!;\n    if (clause1.column === column.name) {\n      return clause2;\n    } else if (clause2.column === column.name) {\n      return clause1;\n    } else {\n      return null;\n    }\n  }\n}\n\nexport function removeFilter(sourceFilter: Filter, filterToRemove: Filter) {\n  if (filterEquals(sourceFilter, filterToRemove, true)) {\n    return null;\n  } else if (sourceFilter.type !== AND) {\n    throw Error(\n      `removeFilter cannot remove ${JSON.stringify(filterToRemove)} from ${JSON.stringify(\n        sourceFilter\n      )}`\n    );\n  } else {\n    const filters = (sourceFilter as AndFilter).filters.filter(\n      (f) => !filterEquals(f, filterToRemove)\n    );\n    return filters.length > 0 ? { type: AND, filters } : null;\n  }\n}\n\nexport function splitFilterOnColumn(\n  filter: Filter | null,\n  columnName: string\n): [Filter | null, Filter | null] {\n  if (!filter) {\n    return [null, null];\n  } else if (filter.colName === columnName) {\n    return [filter, null];\n  } else if (filter.type !== AND) {\n    return [null, filter];\n  } else {\n    const [[columnFilter = null], filters] = partition(\n      (filter as AndFilter).filters,\n      (f) => f.colName === columnName\n    );\n    return filters.length === 1\n      ? [columnFilter, filters[0]]\n      : [columnFilter, { type: AND, filters }];\n  }\n}\n\nexport const overrideColName = (filter: Filter, colName: string): Filter => {\n  const { type } = filter;\n  if (type === AND || type === OR) {\n    return {\n      type,\n      filters: (filter as AndFilter | OrFilter).filters.map((f) => overrideColName(f, colName))\n    };\n  } else {\n    return { ...filter, colName };\n  }\n};\n\nexport function extractFilterForColumn(filter: Filter | null, columnName: string) {\n  if (!filter) {\n    return null;\n  }\n  const { type, colName } = filter;\n  switch (type) {\n    case AND:\n    case OR:\n      return collectFiltersForColumn(type, (filter as AndFilter | OrFilter).filters, columnName);\n    default:\n      return colName === columnName ? filter : null;\n  }\n}\n\nfunction collectFiltersForColumn(type: FilterType, filters: Filter[], columnName: string) {\n  const results: Filter[] = [];\n  filters.forEach((filter) => {\n    const ffc = extractFilterForColumn(filter, columnName);\n    if (ffc !== null) {\n      results.push(ffc);\n    }\n  });\n  if (results.length === 1) {\n    return results[0];\n  } else {\n    return {\n      type,\n      filters: results\n    };\n  }\n}\n\nexport function filterIncludesColumn(filter: Filter, column: Column): boolean {\n  if (!filter) {\n    return false;\n  }\n  const { op, column: filterColName, filters } = filter;\n  switch (op) {\n    case AND:\n    case OR:\n      return filters != null && filters.some((f) => filterIncludesColumn(f, column));\n    default:\n      return filterColName === column.name;\n  }\n}\n\nexport function isAndFilter(filter: Filter): filter is AndFilter {\n  return filter.type === 'and';\n}\n\nexport function isOrFilter(filter: Filter): filter is OrFilter {\n  return filter.type === 'or';\n}\n\nexport function isInFilter(filter: Filter): filter is InFilter {\n  return filter.type === 'in';\n}\n\nexport function isNotInFilter(filter: Filter): filter is NotInFilter {\n  return filter.type === 'NOT_IN';\n}\n\nexport function removeFilterForColumn(sourceFilter: Filter | null, column: Column): Filter | null {\n  const colName = column.name;\n  if (!sourceFilter) {\n    return null;\n  } else if (sourceFilter.colName === colName) {\n    return null;\n  } else if (isAndFilter(sourceFilter) || isOrFilter(sourceFilter)) {\n    const { type } = sourceFilter;\n    const filters = sourceFilter.filters;\n    const otherColFilters = filters.filter((f) => f.colName !== colName);\n    switch (otherColFilters.length) {\n      case 0:\n        return null;\n      case 1:\n        return otherColFilters[0];\n      default:\n        return { type, otherColFilters };\n    }\n  } else {\n    return sourceFilter;\n  }\n}\n\nconst sameColumn = (f1, f2) => f1.column === f2.column;\n\nexport function filterEquals(f1?: Filter, f2?: Filter, strict = false) {\n  if (f1 && f2) {\n    const isSameColumn = sameColumn(f1, f2);\n    if (!strict) {\n      return isSameColumn;\n    } else {\n      return (\n        isSameColumn && f1.op === f2.op && f1.value === f2.value && sameValues(f1.values, f2.values)\n      );\n    }\n  } else {\n    return false;\n  }\n}\n\n// does f2 extend f1 ?\nfunction filterExtends(f1: Filter, f2: Filter): boolean {\n  if (isInFilter(f1) && isInFilter(f2)) {\n    return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n  } else {\n    return false;\n  }\n}\n\n//TODO roll this into next function\nexport function projectFilterData(filterRows: Row[]) {\n  return filterRows.map((row, idx) => [idx, 0, 0, null, row.name, row.count]);\n}\n\n// The folowing are array utilities but they are defined here as they are not suitable for large arrays, so we'll\n// keep them local to filters\nfunction containsAll<T>(superList: T[], subList: T[]): boolean {\n  for (let i = 0, len = subList.length; i < len; i++) {\n    if (superList.indexOf(subList[i]) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// only suitable for small arrays of simple types (e.g. filter values)\nfunction sameValues<T>(arr1: T[], arr2: T[]) {\n  if (arr1 === arr2) {\n    return true;\n  } else if (arr1.length === arr2.length) {\n    const a = arr1.slice().sort();\n    const b = arr2.slice().sort();\n    return a.join('|') === b.join('|');\n  }\n  return false;\n}\n\n// TODO unify all 'partition' implementations\n\ntype Predicate<T> = (x: T) => boolean;\n\nfunction partition<T>(\n  list: T[],\n  test1: Predicate<T>,\n  test2: Predicate<T> | null = null\n): [T[], T[]] | [T[], T[], T[]] {\n  const results1: T[] = [];\n  const misses: T[] = [];\n  const results2: T[] | null = test2 === null ? null : [];\n\n  for (let i = 0; i < list.length; i++) {\n    if (test1(list[i])) {\n      results1.push(list[i]);\n    } else if (test2 !== null && test2(list[i])) {\n      results2!.push(list[i]);\n    } else {\n      misses.push(list[i]);\n    }\n  }\n\n  return test2 === null\n    ? ([results1, misses] as [T[], T[]])\n    : ([results1, results2, misses] as [T[], T[], T[]]);\n}\n", "export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n", "import ascending from \"./ascending.js\";\n\nexport default function(f) {\n  let delta = f;\n  let compare = f;\n\n  if (f.length === 1) {\n    delta = (d, x) => f(d) - x;\n    compare = ascendingComparator(f);\n  }\n\n  function left(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) < 0) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  function right(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) > 0) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  function center(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction ascendingComparator(f) {\n  return (d, x) => ascending(f(d), x);\n}\n", "export default function(x) {\n  return x === null ? NaN : +x;\n}\n\nexport function* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n", "import ascending from \"./ascending.js\";\nimport bisector from \"./bisector.js\";\nimport number from \"./number.js\";\n\nconst ascendingBisect = bisector(ascending);\nexport const bisectRight = ascendingBisect.right;\nexport const bisectLeft = ascendingBisect.left;\nexport const bisectCenter = bisector(number).center;\nexport default bisectRight;\n", "export default function count(values, valueof) {\n  let count = 0;\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        ++count;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n", "export default function(values, valueof) {\n  let min;\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  }\n  return [min, max];\n}\n", "export default function(x) {\n  return x;\n}\n", "var array = Array.prototype;\n\nexport var slice = array.slice;\nexport var map = array.map;\n", "export default function(x) {\n  return function() {\n    return x;\n  };\n}\n", "var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nexport default function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    let r0 = Math.round(start / step), r1 = Math.round(stop / step);\n    if (r0 * step < start) ++r0;\n    if (r1 * step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) * step;\n  } else {\n    step = -step;\n    let r0 = Math.round(start * step), r1 = Math.round(stop * step);\n    if (r0 / step < start) ++r0;\n    if (r1 / step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n", "import {tickIncrement} from \"./ticks.js\";\n\nexport default function nice(start, stop, count) {\n  let prestep;\n  while (true) {\n    const step = tickIncrement(start, stop, count);\n    if (step === prestep || step === 0 || !isFinite(step)) {\n      return [start, stop];\n    } else if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n    }\n    prestep = step;\n  }\n}\n", "import count from \"../count.js\";\n\nexport default function(values) {\n  return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;\n}\n", "import {slice} from \"./array.js\";\nimport bisect from \"./bisect.js\";\nimport constant from \"./constant.js\";\nimport extent from \"./extent.js\";\nimport identity from \"./identity.js\";\nimport nice from \"./nice.js\";\nimport ticks, {tickIncrement} from \"./ticks.js\";\nimport sturges from \"./threshold/sturges.js\";\n\nexport default function() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    if (!Array.isArray(data)) data = Array.from(data);\n\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds, and nice the\n    // default domain accordingly.\n    if (!Array.isArray(tz)) {\n      const max = x1, tn = +tz;\n      if (domain === extent) [x0, x1] = nice(x0, x1, tn);\n      tz = ticks(x0, x1, tn);\n\n      // If the last threshold is coincident with the domain\u2019s upper bound, the\n      // last bin will be zero-width. If the default domain is used, and this\n      // last threshold is coincident with the maximum input value, we can\n      // extend the niced upper bound by one tick to ensure uniform bin widths;\n      // otherwise, we simply remove the last threshold. Note that we don\u2019t\n      // coerce values or the domain to numbers, and thus must be careful to\n      // compare order (>=) rather than strict equality (===)!\n      if (tz[tz.length - 1] >= x1) {\n        if (max >= x1 && domain === extent) {\n          const step = tickIncrement(x0, x1, tn);\n          if (isFinite(step)) {\n            if (step > 0) {\n              x1 = (Math.floor(x1 / step) + 1) * step;\n            } else if (step < 0) {\n              x1 = (Math.ceil(x1 * -step) + 1) / -step;\n            }\n          }\n        } else {\n          tz.pop();\n        }\n      }\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisect(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n}\n", "export interface Event {\n\n}\n\nexport type EventListener = (evtName: string, ...args: any[]) => void;\n\nexport type EventListenerMap = {\n  [eventName: string]: EventListener[] | EventListener;\n}\n\nfunction isArrayOfListeners(listeners: EventListener | EventListener[]): listeners is EventListener[] {\n  return Array.isArray(listeners);\n}\n\nfunction isOnlyListener(listeners: EventListener | EventListener[]): listeners is EventListener {\n  return !Array.isArray(listeners);\n}\n\nexport class EventEmitter {\n  private _events: EventListenerMap;\n\n  constructor() {\n    this._events = {};\n  }\n\n  addListener(type: string, listener: EventListener) {\n    if (!this._events) {\n      this._events = {};\n    }\n\n    const listeners = this._events[type];\n\n    if (!listeners) {\n      this._events[type] = listener;\n    } else if (isArrayOfListeners(listeners)) {\n      listeners.push(listener);\n    } else if (isOnlyListener(listeners)) {\n      this._events[type] = [listeners, listener];\n    }\n  }\n\n  removeListener(type: string, listener: EventListener) {\n    if (!this._events || !this._events[type]) {\n      return;\n    }\n\n    const listenerOrListeners = this._events[type];\n    let position = -1;\n\n    if (listenerOrListeners === listener) {\n      delete this._events[type];\n    } else if (Array.isArray(listenerOrListeners)) {\n      for (let i = length; i-- > 0; ) {\n        if (listenerOrListeners[i] === listener) {\n          position = i;\n          break;\n        }\n      }\n\n      if (position < 0) {\n        return;\n      }\n\n      if (listenerOrListeners.length === 1) {\n        listenerOrListeners.length = 0;\n        delete this._events[type];\n      } else {\n        listenerOrListeners.splice(position, 1);\n      }\n    }\n  }\n\n  removeAllListeners(type: string) {\n    if (!this._events) {\n      return;\n    } else if (type === undefined) {\n      delete this._events;\n    } else {\n      delete this._events[type];\n    }\n  }\n\n  emit(type: string, ...args) {\n    if (this._events) {\n      const handler = this._events[type];\n      if (handler) {\n        invokeHandler(handler, type, args);\n      }\n      const wildcardHandler = this._events['*'];\n      if (wildcardHandler) {\n        invokeHandler(wildcardHandler, type, args);\n      }\n    }\n  }\n\n  once(type: string, listener: EventListener) {\n    const handler = (evtName, message) => {\n      this.removeListener(evtName, handler);\n      listener(evtName, message);\n    };\n\n    this.on(type, handler);\n  }\n\n  on(type: string, listener: EventListener) {\n    return this.addListener(type, listener);\n  }\n}\n\nfunction invokeHandler(handler: EventListener | EventListener[], type: string, args) {\n  if (isArrayOfListeners(handler)) {\n    handler.slice().forEach((listener) => invokeHandler(listener, type, args));\n  } else {\n    switch (args.length) {\n      case 0:\n        handler(type);\n        break;\n      case 1:\n        handler(type, args[0]);\n        break;\n      case 2:\n        handler(type, args[0], args[1]);\n        break;\n      // slower\n      default:\n        handler.call(null, type, ...args);\n    }\n  }\n}\n", "import { EventEmitter } from '@vuu-ui/utils/src/event-emitter';\n\nconst defaultUpdateConfig = {\n  applyUpdates: false,\n  applyInserts: false,\n  interval: 500\n};\n\nfunction buildColumnMap(columns) {\n  if (columns) {\n    const map = { IDX: 0, KEY: 1 };\n    for (let i = 0; i < columns.length; i++) {\n      map[columns[i].name] = i + 2;\n    }\n    return map;\n  } else {\n    return null;\n  }\n}\n\nexport default class Table extends EventEmitter {\n  constructor(config) {\n    super();\n    const { name, columns = null, primaryKey, dataPath, data, updates = {} } = config;\n    this.name = name;\n    this.primaryKey = primaryKey;\n    this.columns = columns;\n    this.keys = {};\n    this.index = {};\n    this.indices = [];\n    this.rows = [];\n    this.updateConfig = {\n      ...defaultUpdateConfig,\n      ...updates\n    };\n    this.inputColumnMap = undefined;\n    this.columnMap = buildColumnMap(columns);\n    this.columnCount = 0;\n    this.status = null;\n\n    if (data) {\n      this.load(data);\n    } else if (dataPath) {\n      this.fetchData(dataPath);\n    }\n\n    this.installDataGenerators(config);\n  }\n\n  update(rowIdx, ...updates) {\n    const results = [];\n    let row = this.rows[rowIdx];\n    for (let i = 0; i < updates.length; i += 2) {\n      const colIdx = updates[i];\n      const value = updates[i + 1];\n      results.push(colIdx, row[colIdx], value);\n      row[colIdx] = value;\n    }\n    this.emit('rowUpdated', rowIdx, results);\n  }\n\n  bulkUpdate(updates, doNotPublish) {\n    const results = [];\n    for (let rowUpdate of updates) {\n      const [idx] = rowUpdate;\n      const row = this.rows[idx];\n      const rowResult = [idx];\n      for (let i = 1; i < rowUpdate.length; i += 2) {\n        const colIdx = rowUpdate[i];\n        const value = rowUpdate[i + 1];\n        rowResult.push(colIdx, row[colIdx], value);\n        row[colIdx] = value;\n      }\n      results.push(rowResult);\n    }\n    this.emit('rowsUpdated', results, doNotPublish);\n  }\n\n  // Don't think this is worth the overhead\n  // bulkUpdate(updates){\n  // const map = new Map();\n  // const results = [];\n  // let rowResult;\n  // for (let rowUpdate of updates){\n  //     const [idx] = rowUpdate;\n  //     const row = this.rows[idx];\n\n  //     if (map.has(idx)){\n  //         rowResult = map.get(idx);\n  //     } else {\n  //         results.push(rowResult = [idx]);\n  //         map.set(idx, rowResult)\n  //     }\n\n  //     for (let i=1;i<rowUpdate.length;i+=2){\n  //         const colIdx = rowUpdate[i];\n  //         const value = rowUpdate[i+1];\n  //         const pos = rowResult.indexOf(colIdx);\n  //         if (pos === -1 || (pos-1)%3){ // don't mistake a value for a column Index\n  //             rowResult.push(colIdx, row[colIdx], value);\n  //         } else {\n  //             // updates are in sequence so later update for same column replaces earlier value\n  //             rowResult.splice(pos+1, 2, row[colIdx], value);\n  //         }\n  //         row[colIdx] = value;\n  //     }\n  // }\n  // console.log(results)\n  // this.emit('rowsUpdated', results);\n  // }\n\n  insert(data) {\n    let columnnameList = this.columns ? this.columns.map((c) => c.name) : null;\n    const idx = this.rows.length;\n    let row = this.rowFromData(idx, data, columnnameList);\n    this.rows.push(row);\n    this.emit('rowInserted', idx, row);\n  }\n\n  remove(key) {\n    if (this.keys[key]) {\n      const index = this.indices[key];\n      delete this.keys[key];\n      delete this.indices[key];\n      this.rows.splice(index, 1);\n\n      for (let k in this.indices) {\n        if (this.indices[k] > index) {\n          this.indices[k] -= 1;\n        }\n      }\n\n      this.emit('rowRemoved', this.name, key);\n    }\n  }\n\n  clear() {}\n\n  toString() {\n    const out = ['\\n' + this.name];\n    out.splice.apply(\n      out,\n      [1, 0].concat(\n        this.rows.map(function (row) {\n          return row.toString();\n        })\n      )\n    );\n    return out.join('\\n');\n  }\n\n  async fetchData(url) {\n    fetch(url, {})\n      .then((data) => data.json())\n      .then((json) => {\n        console.log(`Table.loadData: got ${json.length} rows`);\n        this.load(json);\n      })\n      .catch((err) => {\n        console.error(err);\n      });\n  }\n\n  load(data) {\n    let columnnameList = this.columns ? this.columns.map((c) => c.name) : null;\n    const rows = [];\n    for (let i = 0; i < data.length; i++) {\n      let row = this.rowFromData(i, data[i], columnnameList);\n      rows.push(row);\n    }\n    this.rows = rows;\n\n    if (this.columns === null) {\n      this.columns = columnsFromColumnMap(this.inputColumnMap);\n      this.columnMap = buildColumnMap(this.columns);\n    }\n    this.status = 'ready';\n    this.emit('ready');\n    if (this.updateConfig && this.updateConfig.applyUpdates !== false) {\n      setTimeout(() => {\n        this.applyUpdates();\n      }, 1000);\n    }\n    // move this\n    if (this.updateConfig && this.updateConfig.applyInserts !== false) {\n      setTimeout(() => {\n        this.applyInserts();\n      }, 10000);\n    }\n  }\n\n  // Build a row [idx, primaryKey, ...data values]\n  rowFromData(idx, data, columnnameList) {\n    // 2 metadata items for each row, the idx and unique key\n    const { index, primaryKey = null, columnMap: map } = this;\n\n    if (Array.isArray(data)) {\n      const key = data[map[this.primaryKey] - 2];\n      index[key] = idx;\n      return [idx, key, ...data];\n    } else {\n      // This allows us to load data from objects as rows, without predefined columns, where\n      // not every row may have every column. How would we handle primary key ?\n      const columnMap = map || (this.columnMap = { IDX: 0, KEY: 1 });\n      const colnames = columnnameList || Object.getOwnPropertyNames(data);\n      // why start with idx in 0 ?\n      const row = [idx];\n      let colIdx;\n\n      for (let i = 0; i < colnames.length; i++) {\n        const name = colnames[i];\n        const value = data[name];\n        if ((colIdx = columnMap[name]) === undefined) {\n          colIdx = columnMap[name] = 2 + this.columnCount++;\n        }\n        row[colIdx] = value;\n        // If we don't know the primary key, assume it is the first column for now\n        if (name === primaryKey || (primaryKey === null && i === 0)) {\n          index[value] = idx;\n          row[map.KEY] = value;\n        }\n      }\n      return row;\n    }\n  }\n\n  //TODO move all these methods into an external helper\n  applyInserts() {\n    const idx = this.rows.length;\n    const newRow = this.createRow(idx);\n    if (newRow) {\n      this.insert(newRow);\n    } else {\n      console.log(`createRow did not return a new row`);\n    }\n\n    setTimeout(() => this.applyInserts(), this.updateConfig.insertInterval | 100);\n  }\n\n  applyUpdates() {\n    const { rows, columnMap } = this;\n    // const count = Math.round(rows.length / 50);\n    const count = 100;\n\n    for (let i = 0; i < count; i++) {\n      const rowIdx = getRandomInt(rows.length - 1);\n      const update = this.updateRow(rowIdx, rows[rowIdx], columnMap);\n      if (update) {\n        this.update(rowIdx, ...update);\n      }\n    }\n\n    setTimeout(() => this.applyUpdates(), this.updateConfig.interval);\n  }\n\n  createRow(idx) {\n    console.warn(`createRow ${idx} must be implemented as a plugin`);\n    return null;\n  }\n\n  updateRow() {\n    return null;\n  }\n\n  async installDataGenerators() {\n    //console.warn(`installDataGenerators must be implemented by a more specific subclass`);\n  }\n}\n\nfunction getRandomInt(max) {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n\nfunction columnsFromColumnMap(columnMap) {\n  const columnNames = Object.getOwnPropertyNames(columnMap);\n\n  return columnNames\n    .map((name) => ({ name, key: columnMap[name] }))\n    .sort(byKey)\n    .map(({ name }) => ({ name }));\n}\n\nfunction byKey(col1, col2) {\n  return col1.key - col2.key;\n}\n", "export const CHECKBOX = 'checkbox';\nexport const SINGLE_ROW = 'single-row';\nexport const MULTIPLE_ROW = 'multiple-row';\n\nexport const SelectionModelType = {\n  Checkbox: CHECKBOX,\n  SingleRow: SINGLE_ROW,\n  MultipleRow: MULTIPLE_ROW\n};\n\nconst { Checkbox, SingleRow, MultipleRow } = SelectionModelType;\n\nconst EMPTY = [];\n\nexport function selectionDiffers(selected1, selected2) {\n  const len = selected1.length;\n  if (len !== selected2.length) {\n    return true;\n  }\n  for (let i = 0; i < len; i++) {\n    if (selected1[i] !== selected2[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport default class SelectionModel {\n  constructor(selectionModelType = MultipleRow) {\n    this.modelType = selectionModelType;\n  }\n\n  select({ rows: selection, lastTouchIdx }, idx, rangeSelect, keepExistingSelection) {\n    let selected, deselected;\n\n    if (this.modelType === SingleRow) {\n      [selection, selected, deselected] = this.handleRegularSelection(selection, idx);\n      lastTouchIdx = idx;\n    } else if (rangeSelect) {\n      [selection, selected, deselected] = this.handleRangeSelection(selection, lastTouchIdx, idx);\n    } else if (keepExistingSelection || this.modelType === Checkbox) {\n      [selection, selected, deselected] = this.handleIncrementalSelection(selection, idx);\n      lastTouchIdx = idx;\n    } else {\n      [selection, selected, deselected] = this.handleRegularSelection(selection, idx);\n      lastTouchIdx = idx;\n    }\n\n    return {\n      focusedIdx: idx,\n      lastTouchIdx,\n      rows: selection,\n      selected,\n      deselected\n    };\n  }\n\n  handleRegularSelection(selected, idx) {\n    const pos = selected.indexOf(idx);\n    if (pos === -1) {\n      const selection = [idx];\n      return [selection, selection, selected];\n    } else if (selected.length === 1) {\n      return [EMPTY, EMPTY, selected];\n    } else {\n      return [EMPTY, EMPTY, remove(selected, idx)];\n    }\n  }\n\n  handleIncrementalSelection(selected, idx) {\n    const pos = selected.indexOf(idx);\n    const len = selected.length;\n    const selection = [idx];\n\n    if (pos === -1) {\n      if (len === 0) {\n        return [selection, selection, EMPTY];\n      } else {\n        return [insert(selected, idx), selection, EMPTY];\n      }\n    } else {\n      if (len === 1) {\n        return [EMPTY, EMPTY, selected];\n      } else {\n        return [remove(selected, idx), EMPTY, selection];\n      }\n    }\n  }\n\n  handleRangeSelection(selected, lastTouchIdx, idx) {\n    const pos = selected.indexOf(idx);\n    const len = selected.length;\n\n    if (pos === -1) {\n      if (len === 0) {\n        const selection = makeRange(0, idx);\n        return [selection, selection, EMPTY];\n      } else if (len === 1) {\n        const selection = makeRange(selected[0], idx);\n        selected = selected[0] < idx ? selection.slice(1) : selection.slice(0, -1);\n        return [selection, selected, EMPTY];\n      } else {\n        const selection = applyRange(selected, lastTouchIdx, idx);\n        return [selection, selection.filter((i) => !selected.includes(i)), EMPTY];\n      }\n    } else {\n      // TODO <<<<<<<<<<<<<<<<<\n    }\n  }\n}\n\nfunction applyRange(arr, lo, hi) {\n  if (lo > hi) {\n    [lo, hi] = [hi, lo];\n  }\n\n  const ranges = getRanges(arr);\n  const newRange = new Range(lo, hi);\n  let newRangeAdded = false;\n  const ret = [];\n\n  for (let i = 0; i < ranges.length; i++) {\n    const range = ranges[i];\n\n    if (!range.overlaps(newRange)) {\n      if (range.start < newRange.start) {\n        for (let idx = range.start; idx <= range.end; idx++) {\n          ret.push(idx);\n        }\n      } else {\n        for (let idx = newRange.start; idx <= newRange.end; idx++) {\n          ret.push(idx);\n        }\n        newRangeAdded = true;\n        for (let idx = range.start; idx <= range.end; idx++) {\n          ret.push(idx);\n        }\n      }\n    } else if (!newRangeAdded) {\n      for (let idx = newRange.start; idx <= newRange.end; idx++) {\n        ret.push(idx);\n      }\n      newRangeAdded = true;\n    }\n  }\n\n  if (!newRangeAdded) {\n    for (let idx = newRange.start; idx <= newRange.end; idx++) {\n      ret.push(idx);\n    }\n  }\n\n  return ret;\n}\n\nfunction getRanges(arr) {\n  const ranges = [];\n  let range;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (range && range.touches(arr[i])) {\n      range.extend(arr[i]);\n    } else {\n      ranges.push((range = new Range(arr[i])));\n    }\n  }\n\n  return ranges;\n}\n\nclass Range {\n  constructor(start, end = start) {\n    this.start = start;\n    this.end = end;\n  }\n\n  extend(idx) {\n    if (idx >= this.start && idx > this.end) {\n      this.end = idx;\n    }\n  }\n\n  touches(idx) {\n    return this.end === idx - 1;\n  }\n\n  overlaps(that) {\n    return !(this.end < that.start || this.start > that.end);\n  }\n\n  contains(idx) {\n    return this.start <= idx && this.end >= idx;\n  }\n\n  toString() {\n    return `[${this.start}:${this.end}]`;\n  }\n}\n\nfunction makeRange(lo, hi) {\n  if (lo > hi) {\n    [lo, hi] = [hi, lo];\n  }\n\n  const range = [];\n  for (let idx = lo; idx <= hi; idx++) {\n    range.push(idx);\n  }\n  return range;\n}\n\nfunction remove(arr, idx) {\n  const ret = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (idx !== arr[i]) {\n      ret.push(arr[i]);\n    }\n  }\n  return ret;\n}\n\nfunction insert(arr, idx) {\n  const ret = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (idx !== null && idx < arr[i]) {\n      ret.push(idx);\n      idx = null;\n    }\n    ret.push(arr[i]);\n  }\n  if (idx !== null) {\n    ret.push(idx);\n  }\n  return ret;\n}\n", "const actionKeys = ['Enter', 'Delete'];\nconst navigationKeys = ['Home', 'End', 'ArrowRight', 'ArrowLeft', 'ArrowDown', 'ArrowUp', 'Tab'];\nconst functionKeys = ['F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12'];\n\nconst specialKeys = actionKeys\n  .concat(navigationKeys)\n  .concat(functionKeys)\n  .reduce((map, key) => {\n    map[key] = true;\n    return map;\n  }, {});\n\nexport const isCharacterKey = (evt: KeyboardEvent) => {\n  if (specialKeys[evt.key]) {\n    return false;\n  }\n  if (typeof evt.which === 'number' && evt.which > 0) {\n    return !evt.ctrlKey && !evt.metaKey && !evt.altKey && evt.which !== 8;\n  }\n};\n\nexport const isQuoteKey = (evt: KeyboardEvent) => {\n  console.log(`key = >${evt.key}<`);\n  return evt.key === '\"' || evt.key === \"'\";\n};\n", "export function arrayOfIndices(length: number): number[] {\n  // not the neatest, but far and away the fastest way to do this ...\n  const result = Array(length);\n  for (let i = 0; i < length; i++) {\n    result[i] = i;\n  }\n  return result;\n}\n\nexport type PartitionTest<T> = (value: T, index: number) => boolean;\n\nexport function partition<T>(array: T[], test: PartitionTest<T>, pass: T[] = [], fail: T[] = []): [T[], T[]] {\n  for (let i = 0, len = array.length; i < len; i++) {\n    (test(array[i], i) ? pass : fail).push(array[i]);\n  }\n\n  return [pass, fail];\n}\n", "export const DataTypes = {\n  ROW_DATA: 'rowData',\n  FILTER_DATA: 'filterData',\n  FILTER_BINS: 'filterBins'\n};\n\nexport const ASC = 'asc';\nexport const DSC = 'dsc';\n", "import { functor, overrideColName } from './filter-utils';\nimport {Row} from \"./row-utils\";\n\nconst SORT_ASC = 'asc';\n\nexport type SortCriteriaItem = string | [string, 'asc']; // TODO where is 'desc'?\n\nexport interface ColumnMap {\n  [columnName: string]: number;\n}\n\nexport function mapSortCriteria(\n  sortCriteria: SortCriteriaItem[],\n  columnMap: ColumnMap,\n  metadataOffset = 0\n): [number, 'asc'][] {\n  return sortCriteria.map((s) => {\n    if (typeof s === 'string') {\n      return [columnMap[s] + metadataOffset, 'asc'];\n    } else if (Array.isArray(s)) {\n      const [columnName, sortDir] = s;\n      return [columnMap[columnName] + metadataOffset, sortDir || SORT_ASC];\n    } else {\n      throw Error('columnUtils.mapSortCriteria invalid input');\n    }\n  });\n}\n\nexport interface Column {\n  key?: number;\n  name: string;\n  type?: {\n    name: string;\n  } | string | null;\n}\n\nexport interface KeyedColumn {\n  key: number;\n  name: string;\n  type?: {\n    name: string;\n  } | string | null;\n}\n\nexport function isKeyedColumn(column: Column): column is KeyedColumn {\n  return typeof column.key === 'number';\n}\n\nexport const toKeyedColumn = (column: string | Column, key: number): KeyedColumn => {\n  if (typeof column === 'string') {\n    return {key, name: column};\n  }\n  if (isKeyedColumn(column)) {\n    return column;\n  }\n  return {...column, key};\n}\n\nexport function buildColumnMap(columns?: Column[]): ColumnMap | null {\n  const start = metadataKeys.count;\n  if (columns) {\n    return columns.reduce((map, column, i) => {\n      if (typeof column === 'string') {\n        map[column] = start + i;\n      } else if (typeof column.key === 'number') {\n        map[column.name] = column.key;\n      } else {\n        map[column.name] = start + i;\n      }\n      return map;\n    }, {} as ColumnMap);\n  } else {\n    return null;\n  }\n}\n\nexport function projectUpdates(updates: number[]): number[] {\n  const results: number[] = [];\n  const metadataOffset = metadataKeys.count - 2;\n  for (let i = 0; i < updates.length; i += 3) {\n    results[i] = updates[i] + metadataOffset;\n    results[i + 1] = updates[i + 1];\n    results[i + 2] = updates[i + 2];\n  }\n  return results;\n}\n\nexport function projectColumns(tableRowColumnMap: ColumnMap, columns: Column[]) {\n  const columnCount = columns.length;\n  const { IDX, RENDER_IDX, DEPTH, COUNT, KEY, SELECTED, count } = metadataKeys;\n  return (startIdx: number, offset: number, selectedRows: Row[] = []) =>\n    (row: Row, i: number) => {\n      // selectedRows are indices of rows within underlying dataset (not sorted or filtered)\n      // row is the original row from this set, with original index in IDX pos, which might\n      // be overwritten with a different value below if rows are sorted/filtered\n      const baseRowIdx: any = row[IDX]; // TODO\n      const out = [];\n      for (let i = 0; i < columnCount; i++) {\n        const colIdx = tableRowColumnMap[columns[i].name];\n        out[count + i] = row[colIdx];\n      }\n\n      out[IDX] = startIdx + i + offset;\n      out[RENDER_IDX] = 0;\n      out[DEPTH] = 0;\n      out[COUNT] = 0;\n      out[KEY] = row[tableRowColumnMap.KEY];\n      out[SELECTED] = selectedRows.includes(baseRowIdx) ? 1 : 0;\n      return out;\n    };\n}\n\nexport type Meta = {\n  [key: string]: any;\n} & any[];\n\nexport function projectColumnsFilter(map, columns: Column[], meta: Meta, filter) {\n  const length = columns.length;\n  const { IDX, RENDER_IDX, DEPTH, COUNT, KEY, SELECTED } = meta;\n\n  // this is filterset specific where first col is always value\n  const fn = filter ? functor(map, overrideColName(filter, 'name')) : () => true;\n  return (startIdx) => (row, i) => {\n    const out = [];\n    for (let i = 0; i < length; i++) {\n      const colIdx = map[columns[i].name];\n      out[i] = row[colIdx];\n    }\n    // assume row[0] is key for now\n    // out.push(startIdx+i, 0, 0, row[0]);\n    out[IDX] = startIdx + i;\n    out[RENDER_IDX] = 0;\n    out[DEPTH] = 0;\n    out[COUNT] = 0;\n    out[KEY] = row[map.KEY];\n    out[SELECTED] = fn(row) ? 1 : 0;\n\n    return out;\n  };\n}\n\nexport function getFilterType(column) {\n  return column.filter || filterTypeFromColumnType(column);\n}\n\n// {name: 'Price', 'type': {name: 'price'}, 'aggregate': 'avg'},\n// {name: 'MarketCap', 'type': {name: 'number','format': 'currency'}, 'aggregate': 'sum'},\n\nconst filterTypeFromColumnType = (column: Column) => {\n  // TODO add remaining filter types\n  switch (getDataType(column)) {\n    case 'number':\n      return 'number';\n    default:\n      return 'set';\n  }\n};\n\nexport function getDataType({ type = null }: Column ) {\n  if (type === null) {\n    return 'set';\n  } else if (typeof type === 'string') {\n    return type;\n  } else {\n    switch (type!.name) {\n      case 'price':\n        return 'number';\n      default:\n        return type.name;\n    }\n  }\n}\n\nexport const metadataKeys = {\n  IDX: 0,\n  RENDER_IDX: 1,\n  IS_LEAF: 2,\n  IS_EXPANDED: 3,\n  DEPTH: 4,\n  COUNT: 5,\n  KEY: 6,\n  SELECTED: 7,\n  count: 8,\n  PARENT_IDX: 'parent_idx',\n  IDX_POINTER: 'idx_pointer',\n  FILTER_COUNT: 'filter_count',\n  NEXT_FILTER_IDX: 'next_filter_idx'\n};\n", "import {FromToRange} from \"../../data-remote/src/servers/vuu/buffer-range\";\n\nexport interface VuuRange {\n  lo?: number;\n  hi?: number;\n  from: number;\n  to: number;\n}\n\nexport function getFullRange(\n  { from, to, lo = from, hi = to }: VuuRange,\n  bufferSize: number = 0,\n  rowCount: number = Number.MAX_SAFE_INTEGER\n): FromToRange {\n  if (bufferSize === 0) {\n    return { from: lo, to: Math.min(hi, rowCount) };\n  } else if (lo === 0) {\n    return { from: lo, to: Math.min(hi + bufferSize, rowCount) };\n  } else {\n    const rangeSize = hi - lo;\n    const buff = Math.round(bufferSize / 2);\n    const shortfallBefore = lo - buff < 0;\n    const shortFallAfter = rowCount - (hi + buff) < 0;\n\n    if (shortfallBefore && shortFallAfter) {\n      return { from: 0, to: rowCount };\n    } else if (shortfallBefore) {\n      return { from: 0, to: rangeSize + bufferSize };\n    } else if (shortFallAfter) {\n      return { from: Math.max(0, rowCount - (rangeSize + bufferSize)), to: rowCount };\n    } else {\n      return { from: lo - buff, to: hi + buff };\n    }\n  }\n}\n\nexport function resetRange({ lo, hi, bufferSize = 0 }) {\n  return {\n    lo: 0,\n    hi: hi - lo,\n    bufferSize,\n    reset: true\n  };\n}\n\nexport class WindowRange {\n  public from: number;\n  public to: number;\n\n  constructor(from: number, to: number) {\n    this.from = from;\n    this.to = to;\n  }\n\n  public isWithin(index: number) {\n    return index >= this.from && index < this.to;\n  }\n\n  //find the overlap of this range and a new one\n  public overlap(from: number, to: number): [number, number] {\n    return from >= this.to || to < this.from\n      ? [0, 0]\n      : [Math.max(from, this.from), Math.min(to, this.to)];\n  }\n\n  public copy(): WindowRange {\n    return new WindowRange(this.from, this.to);\n  }\n}\n", "export type RowIndex = {\n  [field: string]: number;\n}\n\n// TODO\nexport type Row = {\n  [strKey: string]: any;\n} & any[];\n\nexport function addRowsToIndex(rows: Row[], index: RowIndex, indexField: string) {\n  for (let idx = 0, len = rows.length; idx < len; idx++) {\n    index[rows[idx][indexField]] = idx;\n  }\n  return index;\n}\n\nexport function indexRows(rows: Row[], indexField: string) {\n  return addRowsToIndex(rows, {}, indexField);\n}\n\nexport function isEmptyRow(row: Row) {\n  return row[0] === undefined;\n}\n\n// TODO rename\nexport function update(rows: Row[], updates: any) { // TODO\n  const results = rows.slice();\n  const [[offsetIdx]] = rows;\n  for (let i = 0; i < updates.length; i++) {\n    const idx = updates[i][0] - offsetIdx;\n    // slow, refactor for performance\n    if (rows[idx]) {\n      const row = rows[idx].slice();\n      for (let j = 1; j < updates[i].length; j += 3) {\n        row[updates[i][j]] = updates[i][j + 2];\n      }\n      results[idx] = row;\n    } else {\n      console.log(`row not found in rows`);\n    }\n  }\n\n  return results;\n}\n", "import { ASC, DSC, mapSortCriteria } from '@vuu-ui/utils';\n\nexport function sortableFilterSet(filterSet) {\n  if (filterSet.length === 0) {\n    return filterSet;\n  } else if (Array.isArray(filterSet[0])) {\n    return filterSet;\n  } else {\n    return filterSet.map((idx) => [idx, null]);\n  }\n}\n\nexport function sortExtend(sortSet, rows, newSortCols, columnMap) {\n  sort2ColsAdd1(sortSet, rows, newSortCols, columnMap);\n}\n\nexport function sort(sortSet, rows, sortCols, columnMap) {\n  const sortCriteria = mapSortCriteria(sortCols, columnMap);\n  const count = sortCriteria.length;\n  const sortFn = count === 1 ? sort1 : count === 2 ? sort2 : count === 3 ? sort3 : sortAll;\n  sortFn(sortSet, rows, sortCriteria);\n}\n\nfunction sort2ColsAdd1(sortSet, rows, sortCols, columnMap) {\n  const len = sortSet.length;\n  const sortCriteria = mapSortCriteria(sortCols, columnMap);\n  const [colIdx2] = sortCriteria[1];\n  for (let i = 0; i < len; i++) {\n    sortSet[i][2] = rows[sortSet[i][0]][colIdx2];\n  }\n  // This does not take direction into account\n  sortSet.sort((a, b) => {\n    return a[1] > b[1] ? 1 : b[1] > a[1] ? -1 : a[2] > b[2] ? 1 : b[2] > a[2] ? -1 : 0;\n  });\n}\n\nfunction sort1(sortSet, rows, [[colIdx, direction]]) {\n  const len = sortSet.length;\n  for (let i = 0; i < len; i++) {\n    const idx = sortSet[i][0];\n    sortSet[i][1] = rows[idx][colIdx];\n  }\n  if (direction === ASC) {\n    sortSet.sort((a, b) => {\n      return a[1] > b[1] ? 1 : b[1] > a[1] ? -1 : 0;\n    });\n  } else {\n    sortSet.sort((a, b) => {\n      return a[1] > b[1] ? -1 : b[1] > a[1] ? 1 : 0;\n    });\n  }\n}\n\nfunction sort2(sortSet, rows, sortCriteria) {\n  const len = rows.length;\n  const [colIdx1] = sortCriteria[0];\n  const [colIdx2] = sortCriteria[1];\n  for (let i = 0; i < len; i++) {\n    sortSet[i][0] = i;\n    sortSet[i][1] = rows[i][colIdx1];\n    sortSet[i][2] = rows[i][colIdx2];\n  }\n  sortSet.sort((a, b) => {\n    return a[1] > b[1] ? 1 : b[1] > a[1] ? -1 : a[2] > b[2] ? 1 : b[2] > a[2] ? -1 : 0;\n  });\n}\n\nfunction sort3(/*sortSet,rows,sortCriteria*/) {}\nfunction sortAll(/*sortSet,rows,sortCriteria*/) {}\n\nexport function binarySearch(items, item, comparator) {\n  let l = 0;\n  let h = items.length - 1;\n  let m;\n  let comparison;\n\n  while (l <= h) {\n    m = (l + h) >>> 1; /* equivalent to Math.floor((l + h) / 2) but faster */\n    comparison = comparator(items[m], item);\n    if (comparison < 0) {\n      l = m + 1;\n    } else if (comparison > 0) {\n      h = m - 1;\n    } else {\n      return m;\n    }\n  }\n  return ~l;\n}\n\nexport function binaryInsert(rows, row, comparator) {\n  var i = binarySearch(rows, row, comparator);\n  /* if the binarySearch return value was zero or positive, a matching object was found */\n  /* if the return value was negative, the bitwise complement of the return value is the correct index for this object */\n  if (i < 0) {\n    i = ~i;\n  }\n  rows.splice(i, 0, row);\n  return i;\n}\n\nfunction processTail(tail, row, tailGateKeeper, n, compare) {\n  const diff = tailGateKeeper === null ? -1 : compare(row, tailGateKeeper);\n\n  if (diff > 0 || tail.length < n) {\n    binaryInsert(tail, row, compare);\n    if (tail.length > n) {\n      tail.shift();\n    }\n    tailGateKeeper = tail[0];\n  }\n  return tailGateKeeper;\n}\n\n// this is always called with a single col sort\nexport function sortedLowestAndHighest(rows, sortCriteria, offset, n = 1000) {\n  const s1 = new Date().getTime();\n  const compare = sortBy(sortCriteria);\n  const head = rows.slice(0, n).sort(compare);\n  const tail = [];\n  const len = rows.length;\n\n  let headGateKeeper = head[n - 1];\n  let tailGateKeeper = null;\n\n  for (let i = n; i < len; i++) {\n    if (compare(rows[i], headGateKeeper) < 0) {\n      binaryInsert(head, rows[i], compare);\n      // We need to remove largest item from head, does it belong in tail ?\n      tailGateKeeper = processTail(tail, head.pop(), tailGateKeeper, n, compare);\n      headGateKeeper = head[n - 1];\n    } else {\n      tailGateKeeper = processTail(tail, rows[i], tailGateKeeper, n, compare);\n    }\n  }\n\n  for (let i = 0; i < head.length; i++) {\n    const row = head[i].slice();\n    row[0] = i + offset;\n    head[i] = row;\n  }\n\n  for (let i = 0, idx = len - n; i < tail.length; i++, idx++) {\n    const row = tail[i].slice();\n    row[0] = idx + offset;\n    tail[i] = row;\n  }\n\n  const s2 = new Date().getTime();\n  console.log(`lowest ${n} took ${s2 - s1} ms , producing ${head.length} lowest `);\n\n  return [head, tail];\n}\n\nexport function sortReversed(cols1, cols2, colCount = cols1.length) {\n  if (cols1 && cols2 && cols1.length > 0 && cols2.length === colCount) {\n    for (let i = 0; i < colCount; i++) {\n      let [col1, direction1 = ASC] = cols1[i];\n      let [col2, direction2 = ASC] = cols2[i];\n      if (col1 !== col2 || direction1 === direction2) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function GROUP_ROW_TEST(group, row, [colIdx, direction]) {\n  if (group === row) {\n    return 0;\n  } else {\n    let a1 = direction === DSC ? row[colIdx] : group[colIdx];\n    let b1 = direction === DSC ? group[colIdx] : row[colIdx];\n    if (b1 === null || a1 > b1) {\n      return 1;\n    } else if (a1 == null || a1 < b1) {\n      return -1;\n    }\n  }\n}\n\nfunction ROW_SORT_TEST(a, b, [colIdx, direction]) {\n  if (a === b) {\n    return 0;\n  } else {\n    let a1 = direction === DSC ? b[colIdx] : a[colIdx];\n    let b1 = direction === DSC ? a[colIdx] : b[colIdx];\n    if (b1 === null || a1 > b1) {\n      return 1;\n    } else if (a1 == null || a1 < b1) {\n      return -1;\n    }\n  }\n}\n\n// sort null as low. not high\nexport function sortBy(cols, test = ROW_SORT_TEST) {\n  return function (a, b) {\n    for (let i = 0, result = 0, len = cols.length; i < len; i++) {\n      // eslint-disable-next-line no-cond-assign\n      if ((result = test(a, b, cols[i]))) {\n        return result;\n      }\n    }\n    return 0;\n  };\n}\n\n// sorter is the sort comparator used to sort rows, we want to know\n// where row would be positioned in this sorted array. Return the\n// last valid position.\nexport function sortPosition(rows, sorter, row, positionWithinRange = 'last-available') {\n  function selectFromRange(pos) {\n    const len = rows.length;\n    const matches = (p) => sorter(rows[p], row) === 0;\n\n    //TODO this will depend on the sort direction\n    if (positionWithinRange === 'last-available') {\n      while (pos < len && matches(pos)) {\n        pos += 1;\n      }\n    } else if (positionWithinRange === 'first-available') {\n      while (pos > 0 && matches(pos - 1)) {\n        pos -= 1;\n      }\n    }\n\n    return pos;\n  }\n\n  function find(lo, hi) {\n    let mid = lo + Math.floor((hi - lo) / 2);\n    let pos = sorter(rows[mid], row);\n\n    if (lo === mid) {\n      return selectFromRange(pos >= 0 ? lo : hi);\n    }\n    if (pos >= 0) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n    return find(lo, hi);\n  }\n\n  if (rows.length === 0) {\n    return 0;\n  } else {\n    return find(0, rows.length);\n  }\n}\n", "import { sortBy, sortPosition, GROUP_ROW_TEST } from './sort';\nimport { metadataKeys } from '@vuu-ui/utils';\n\nconst {\n  IDX,\n  RENDER_IDX,\n  IS_LEAF,\n  IS_EXPANDED,\n  DEPTH,\n  COUNT,\n  KEY,\n  SELECTED,\n  // these all needto be adjusted by column count\n  PARENT_IDX,\n  IDX_POINTER,\n  FILTER_COUNT,\n  NEXT_FILTER_IDX,\n  count: metadataOffset\n} = metadataKeys;\n\nconst DEFAULT_OPTIONS = {\n  startIdx: 0,\n  rootIdx: null,\n  baseGroupby: []\n};\n\nconst GROUP_KEY_DELIMITER = '|';\n\nexport function indexOfCol(key, cols = null) {\n  if (cols !== null) {\n    for (let i = 0; i < cols.length; i++) {\n      // check both while we transition from groupBy to extendedGroupby\n      // groupBy = [colName, dir] extendedGroupby = [colIdx, dir,colName]\n      const [col1, , col2] = cols[i];\n      if (col1 === key || col2 === key) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n// // should be called toggleColumnInGroupBy\n// export function updateGroupBy(existingGroupBy = null, column/*, replace = false*/) {\n//   console.log(``)\n//   if (existingGroupBy === null) {\n//       return [[column.name, ASC]];\n//   } else {\n//       return indexOfCol(column.name, existingGroupBy) === -1\n//           ? existingGroupBy.concat([[column.name, ASC]])\n//           : existingGroupBy.length === 1\n//               ? null\n//               : existingGroupBy.filter(([colName]) => colName !== column.name);\n//   }\n// }\n\n/** @type {import('./group-utils').lowestIdxPointerFunc} */\nexport function lowestIdxPointer(groups, IDX, DEPTH, start, depth) {\n  let result = Number.MAX_SAFE_INTEGER;\n  for (let i = start; i < groups.length; i++) {\n    const group = groups[i];\n    const groupDepth = group[DEPTH];\n\n    if (groupDepth < depth) {\n      break;\n    } else if (groupDepth === depth) {\n      const idx = group[IDX];\n      if (typeof idx === 'number' && idx < result) {\n        result = idx;\n      }\n    }\n  }\n\n  return result === Number.MAX_SAFE_INTEGER ? undefined : result;\n}\n\n/** @type {import('./group-utils').getCountFunc} */\nexport function getCount(groupRow, PRIMARY_COUNT, FALLBACK_COUNT) {\n  return typeof groupRow[PRIMARY_COUNT] === 'number'\n    ? groupRow[PRIMARY_COUNT]\n    : groupRow[FALLBACK_COUNT];\n}\n\nexport class SimpleTracker {\n  constructor(levels) {\n    this.levels = Array(levels)\n      .fill(0)\n      .reduce((acc, el, i) => {\n        acc[i + 1] = { key: null, pos: null, pPos: null };\n        return acc;\n      }, {});\n  }\n  set(depth, pos, groupKey) {\n    if (this.levels) {\n      const level = this.levels[Math.abs(depth)];\n      if (level && level.key !== groupKey) {\n        if (level.key !== null) {\n          level.pPos = level.pos;\n        }\n        level.key = groupKey;\n        level.pos = pos;\n      }\n    }\n  }\n\n  hasParentPos(level) {\n    return this.levels[level + 1] && this.levels[level + 1].pos !== null;\n  }\n\n  parentPos(level) {\n    return this.levels[level + 1].pos;\n  }\n\n  hasPreviousPos(level) {\n    return this.levels[level] && this.levels[level].pPos !== null;\n  }\n\n  previousPos(level) {\n    return this.levels[level].pPos;\n  }\n}\n\nexport class GroupIdxTracker {\n  constructor(levels) {\n    this.idxAdjustment = 0;\n    this.maxLevel = levels + 1;\n    this.levels =\n      levels > 0\n        ? Array(levels)\n            .fill(0)\n            .reduce((acc, el, i) => {\n              acc[i + 2] = { key: null, current: 0, previous: 0 };\n              return acc;\n            }, {})\n        : null;\n  }\n\n  increment(count) {\n    this.idxAdjustment += count;\n    if (this.levels) {\n      for (let i = 2; i < this.maxLevel + 1; i++) {\n        this.levels[i].current += count;\n      }\n    }\n  }\n\n  previous(level) {\n    return (this.levels && this.levels[level] && this.levels[level].previous) || 0;\n  }\n\n  hasPrevious(level) {\n    return this.previous(level) > 0;\n  }\n\n  get(idx) {\n    return this.levels === null ? null : this.levels[idx];\n  }\n\n  set(depth, groupKey) {\n    if (this.levels) {\n      const level = this.levels[depth];\n      if (level && level.key !== groupKey) {\n        if (level.key !== null) {\n          level.previous += level.current;\n          level.current = 0;\n        }\n        level.key = groupKey;\n      }\n    }\n  }\n}\n\nconst itemIsNumeric = (item) => !isNaN(parseInt(item, 10));\nconst numerically = (a, b) => parseInt(a) - parseInt(b);\n\nfunction sortKeys(o) {\n  const keys = Object.keys(o);\n  if (keys.every(itemIsNumeric)) {\n    return keys.sort(numerically);\n  } else {\n    return keys.sort();\n  }\n}\n\nexport function fillNavSetsFromGroups(\n  groups,\n  sortSet,\n  sortIdx = 0,\n  filterSet = null,\n  filterIdx,\n  filterLen\n) {\n  const keys = sortKeys(groups);\n  const filtered = filterSet !== null;\n  const filterIndices = filtered ? filterSet.slice(filterIdx, filterLen) : null;\n  for (let i = 0; i < keys.length; i++) {\n    const groupedRows = groups[keys[i]];\n    if (Array.isArray(groupedRows)) {\n      for (let j = 0, len = groupedRows.length; j < len; j++) {\n        const rowIdx = groupedRows[j];\n        sortSet[sortIdx] = rowIdx;\n        sortIdx += 1;\n        // this could be prohibitively slow (the includes test) ...\n        if (filtered && filterIndices.includes(rowIdx)) {\n          filterSet[filterIdx] = rowIdx;\n          filterIdx += 1;\n        }\n      }\n    } else {\n      sortIdx = fillNavSetsFromGroups(groupedRows, sortSet, sortIdx);\n    }\n  }\n  return sortIdx;\n}\n\n// WHY is param order different from groupLeafRows\n/** @type {import('./group-utils').groupRowsFunc} */\nexport function groupRows(rows, sortSet, columns, columnMap, groupby, options = DEFAULT_OPTIONS) {\n  const {\n    startIdx = 0,\n    length = rows.length,\n    rootIdx = null,\n    baseGroupby = [],\n    groups = [],\n    rowParents = null,\n    filterLength,\n    filterSet,\n    filterFn: filter\n  } = options;\n  let { depth: depthProp = 1, groupIdx = -1, filterIdx } = options;\n  const aggregations = findAggregatedColumns(columns, columnMap, groupby);\n  const groupedLeafRows = groupLeafRows(sortSet, rows, groupby, startIdx, length);\n  fillNavSetsFromGroups(groupedLeafRows, sortSet, startIdx, filterSet, filterIdx, filterLength);\n\n  const groupCount = groupby.length;\n  const fullGroupCount = groupCount + baseGroupby.length;\n  const currentGroups = Array(groupCount).fill(null);\n  let parentIdx = rootIdx;\n  let leafCount = 0;\n  for (let i = startIdx, len = startIdx + length; i < len; i++) {\n    const rowIdx = sortSet[i];\n    const row = rows[rowIdx];\n\n    for (let level = 0; level < groupCount; level++) {\n      const [columnIdx] = groupby[level];\n      const currentGroup = currentGroups[level];\n      const groupValue = row[columnIdx];\n      // as soon as we identify a group change, each group at that level and below\n      // is then aggregated and new group(s) initiated.\n      // TODO how do we map from table idx (with 2 x metadata)\n      if (\n        currentGroup === null ||\n        currentGroup[metadataOffset + columnIdx - 2 /* !!!!!!! */] !== groupValue\n      ) {\n        if (currentGroup !== null) {\n          // as soon as we know we're regrouping, aggregate the open groups, in reverse order\n          for (let ii = groupCount - 1; ii >= level; ii--) {\n            const group = currentGroups[ii];\n            aggregate(\n              group,\n              groups,\n              sortSet,\n              rows,\n              aggregations,\n              fullGroupCount,\n              leafCount,\n              filter\n            );\n            if (filterSet && Math.abs(group[DEPTH]) === 1 && group[FILTER_COUNT] > 0) {\n              group[NEXT_FILTER_IDX] = filterIdx;\n              filterIdx += group[FILTER_COUNT];\n            }\n          }\n\n          leafCount = 0;\n        }\n        for (let ii = level; ii < groupCount; ii++) {\n          groupIdx += 1;\n          parentIdx = ii === 0 ? rootIdx : currentGroups[ii - 1][IDX];\n          const depth = depthProp + ii;\n          // for first-level groups, row pointer is a pointer into the sortSet\n          const childIdx = depth === fullGroupCount ? i : groupIdx + 1;\n\n          const groupRow = (currentGroups[ii] = GroupRow(\n            row,\n            depth,\n            groupIdx,\n            childIdx,\n            parentIdx,\n            groupby,\n            columns,\n            columnMap,\n            baseGroupby\n          ));\n          groups.push(groupRow);\n        }\n        break; // do not continue looping once we identify the change point\n      }\n    }\n    rowParents && (rowParents[rowIdx] = groupIdx);\n    leafCount += 1;\n  }\n\n  // aggregation for last group\n  for (let i = groupCount - 1; i >= 0; i--) {\n    if (currentGroups[i] !== null) {\n      const group = currentGroups[i];\n      aggregate(group, groups, sortSet, rows, aggregations, fullGroupCount, leafCount, filter);\n      if (filterSet && Math.abs(group[DEPTH]) === 1 && group[FILTER_COUNT] > 0) {\n        group[NEXT_FILTER_IDX] = filterIdx;\n      }\n    }\n  }\n\n  return groups;\n}\n\n// Checks very specifically for new cols added at end\n/** @type {import('./group-utils').groupbyExtendsExistingGroupby} */\nexport function groupbyExtendsExistingGroupby(groupBy, existingGroupBy) {\n  return (\n    groupBy.length > existingGroupBy.length &&\n    existingGroupBy.every((g, i) => g[0] === groupBy[i][0])\n  );\n}\n\n// doesn't care from which position col is removed, as long as it is not the first\n/** @type {import('./group-utils').groupbyReducesExistingGroupby} */\nexport function groupbyReducesExistingGroupby(groupby, existingGroupby) {\n  return (\n    existingGroupby.length > groupby.length &&\n    groupby[0][0] === existingGroupby[0][0] &&\n    groupby.every(([key]) => existingGroupby.find(([key2]) => key2 === key))\n  );\n}\n\n/** @type {import('./group-utils').groupbySortReversed} */\nexport function groupbySortReversed(groupBy, existingGroupBy) {\n  const [col] = findSortedCol(groupBy, existingGroupBy);\n  return col !== null;\n}\n\n/** @type {import('./group-utils').findDoomedColumnDepths} */\nexport function findDoomedColumnDepths(groupby, existingGroupby) {\n  return existingGroupby.reduce((results, [colIdx], idx) => {\n    if (!groupby.some((group) => group[0] === colIdx)) {\n      results.push(idx + 1);\n    }\n    return results;\n  }, []);\n}\n\n/** @type {import('./group-utils').groupbyExtendsExistingGroupby} */\nexport function findSortedCol(groupby, existingGroupby) {\n  let results = [null];\n  let len1 = groupby && groupby.length;\n  let len2 = existingGroupby && existingGroupby.length;\n  if (len1 && len2 && len1 === len2) {\n    for (let i = 0; i < len1; i++) {\n      if (groupby[i][0] !== existingGroupby[i][0]) {\n        return results;\n      } else if (groupby[i][1] !== existingGroupby[i][1]) {\n        results[0] = i;\n        results[1] = len1 - i;\n      }\n    }\n  }\n  return results;\n}\n\nfunction byKey([key1], [key2]) {\n  return key1 > key2 ? 1 : key2 > key1 ? -1 : 0;\n}\n\nconst EMPTY = {};\n/** @type {import('./group-utils').getGroupStateChanges} */\nexport function getGroupStateChanges(\n  groupState,\n  existingGroupState = null,\n  baseKey = '',\n  groupIdx = 0\n) {\n  const results = [];\n  const entries = Object.entries(groupState);\n\n  entries.forEach(([key, value]) => {\n    if (value && (existingGroupState === null || !existingGroupState[key])) {\n      results.push([baseKey + key, groupIdx, true]);\n      if (value !== null && typeof value === 'object' && Object.keys(value).length > 0) {\n        const diff = getGroupStateChanges(value, EMPTY, baseKey + key + '/', groupIdx + 1);\n        if (diff.length) {\n          results.push(...diff);\n        }\n      }\n    } else if (value) {\n      const diff = getGroupStateChanges(\n        value,\n        existingGroupState[key],\n        baseKey + key + '/',\n        groupIdx + 1\n      );\n      if (diff.length) {\n        results.push(...diff);\n      }\n    }\n  });\n\n  if (existingGroupState !== null && typeof existingGroupState === 'object') {\n    Object.entries(existingGroupState).forEach(([key, value]) => {\n      if (value && !groupState[key]) {\n        results.push([baseKey + key, groupIdx, false]);\n      }\n    });\n  }\n\n  return results.sort(byKey);\n}\n\nexport function getDirection(depth, groupby) {\n  const idx = groupby.length - depth;\n  const [, direction] = groupby[idx];\n  return direction;\n}\n\n/** @type {import('./group-utils').expanded} */\nexport function expanded(group, groupby, groupState) {\n  const groupIdx = groupby.length - Math.abs(group[1]);\n  let groupVal;\n  let stateEntry = groupState;\n  for (let i = 0; i <= groupIdx; i++) {\n    const [colIdx] = groupby[i];\n    groupVal = group[colIdx];\n    if (i === groupIdx) {\n      return stateEntry[groupVal];\n    } else {\n      stateEntry = stateEntry[groupVal];\n      if (!stateEntry) {\n        return false;\n      }\n    }\n  }\n  return false;\n}\n\n/** @type {import('./group-utils').allGroupsExpanded} */\nexport function allGroupsExpanded(groups, group) {\n  do {\n    if (group[DEPTH] < 0) {\n      return false;\n    }\n    group = groups[group[PARENT_IDX]];\n  } while (group);\n\n  return true;\n}\n\n/** @type {import('./group-utils').adjustGroupIndices} */\nexport function adjustGroupIndices(groups, grpIdx, adjustment = 1) {\n  for (let i = 0; i < groups.length; i++) {\n    if (groups[i][IDX] >= grpIdx) {\n      groups[i][IDX] += adjustment;\n      if (Math.abs(groups[i][DEPTH]) > 1) {\n        groups[i][IDX_POINTER] += adjustment;\n      }\n      let parentIdx = groups[i][PARENT_IDX];\n      if (parentIdx !== null && parentIdx >= grpIdx) {\n        groups[i][PARENT_IDX] += adjustment;\n      }\n    }\n  }\n}\n\n/** @type {import('./group-utils').adjustLeafIdxPointers} */\nexport function adjustLeafIdxPointers(groups, insertionPoint, adjustment = 1) {\n  for (let i = 0; i < groups.length; i++) {\n    if (Math.abs(groups[i][DEPTH]) === 1 && groups[i][IDX_POINTER] >= insertionPoint) {\n      groups[i][IDX_POINTER] += adjustment;\n    }\n  }\n}\n\n/**\n * Find the groups that will be affectes by an inserted row.\n *\n * @type {import('./group-utils').findGroupPositions} */\nexport function findGroupPositions(groups, groupby, dataRow) {\n  const positions = [];\n\n  out: for (let i = 0; i < groupby.length; i++) {\n    const sorter = sortBy(groupby.slice(0, i + 1), GROUP_ROW_TEST);\n    const position = sortPosition(groups, sorter, dataRow, 'first-available');\n    const group = groups[position];\n    // if all groups are missing and insert position is end of list ...\n    if (group === undefined) {\n      break;\n    }\n    // position is confirmed if all groupCol values in this comparison match values of row\n    // and other groupCol values  are null\n    for (let j = 0; j < groupby.length; j++) {\n      const colIdx = groupby[j][0];\n      const colValue = group[colIdx];\n      if (j > i) {\n        if (colValue !== null) {\n          break out;\n        }\n      } else if (colValue !== dataRow[colIdx]) {\n        break out;\n      }\n    }\n    positions.push(position);\n  }\n\n  return positions;\n}\n\n/** @type {import('./group-utils').expandRow} */\nexport const expandRow = (groupCols, row, meta) => {\n  const r = row.slice();\n  r[meta.IDX] = 0;\n  r[meta.DEPTH] = 0;\n  r[meta.COUNT] = 0;\n  r[meta.KEY] = buildGroupKey(groupCols, row);\n  r[meta.SELECTED] = 0;\n  return r;\n};\n\nfunction buildGroupKey(groupby, row) {\n  const extractKey = ([idx]) => row[idx];\n  return groupby.map(extractKey).join('/');\n}\n\n// Do we have to take columnMap out again ?\nexport function GroupRow(\n  row,\n  depth,\n  idx,\n  childIdx,\n  parentIdx,\n  groupby,\n  columns,\n  columnMap,\n  baseGroupby = []\n) {\n  // The group is a set of metadata values plus data values\n  const group = Array(metadataOffset + columns.length);\n  // const groupIdx = groupby.length - depth;\n  const groupIdx = depth - 1;\n  let colIdx;\n\n  for (let i = 0; i < columns.length; i++) {\n    const column = columns[i];\n    const key = columnMap[column.name];\n    // careful here, key maps to the table row (includes 2 metadata slots), groupBy has also been translated to table keys\n    // the group represents a full projection, metadata + columns\n    const groupKey = metadataOffset + i;\n    if (column.aggregate) {\n      // implies we can't group on aggregate columns, does the UI know that ?\n      group[groupKey] = 0;\n    } else if ((colIdx = indexOfCol(key, groupby)) !== -1 && colIdx <= groupIdx) {\n      group[groupKey] = row[key];\n    } else {\n      group[groupKey] = null;\n    }\n  }\n  for (let i = 0; i < baseGroupby.length; i++) {\n    // baseGroupBy offsets are tableRow offsets, with 2 slots of metadata\n    const [colIdx] = baseGroupby[i];\n    // TODO need to convert colIdx to columns ref\n    group[metadataOffset + colIdx - 2] = row[colIdx];\n  }\n\n  const extractKey = ([idx]) => row[idx];\n  const buildKey = (groupby) => groupby.map(extractKey).join(GROUP_KEY_DELIMITER);\n  //TODO build the composite key for the grouprow\n  const keyRoot = '$root' + GROUP_KEY_DELIMITER;\n  const baseKey =\n    baseGroupby.length > 0 ? keyRoot + buildKey(baseGroupby) + GROUP_KEY_DELIMITER : keyRoot;\n  const groupKey = buildKey(groupby.slice(0, groupIdx + 1));\n\n  group[IDX] = idx;\n  group[RENDER_IDX] = 0;\n  group[IS_LEAF] = false;\n  group[IS_EXPANDED] = false;\n  group[DEPTH] = depth;\n  group[COUNT] = 0;\n  group[KEY] = baseKey + groupKey;\n  group[SELECTED] = 0;\n  group[PARENT_IDX] = parentIdx;\n  group[IDX_POINTER] = childIdx;\n\n  return group;\n}\n\nexport function groupLeafRows(sortSet, leafRows, groupby, startIdx = 0, length = sortSet.length) {\n  const groups = {};\n  const levels = groupby.length;\n  const lastLevel = levels - 1;\n  for (let i = startIdx, len = startIdx + length; i < len; i++) {\n    const idx = sortSet[i];\n    const leafRow = leafRows[idx];\n    let target = groups;\n    let targetKey;\n    let key;\n    for (let level = 0; level < levels; level++) {\n      const [colIdx] = groupby[level];\n      key = leafRow[colIdx];\n      targetKey = target[key];\n      if (targetKey && level === lastLevel) {\n        targetKey.push(idx);\n      } else if (targetKey) {\n        target = targetKey;\n      } else if (!targetKey && level < lastLevel) {\n        target = target[key] = {};\n      } else if (!targetKey) {\n        target[key] = [idx];\n      }\n    }\n  }\n  return groups;\n}\n\n/** @type {import('./group-utils').splitGroupsAroundDoomedGroup} */\nexport function splitGroupsAroundDoomedGroup(groupby, doomed) {\n  const maxDepth = groupby.length;\n  const lastGroupIsDoomed = doomed === maxDepth;\n  const doomedIdx = doomed - 1;\n  const preDoomedGroupby = [];\n  const postDoomedGroupby = [];\n\n  groupby.forEach((col, i) => {\n    if (i < doomedIdx) {\n      preDoomedGroupby.push(col);\n    } else if (i > doomedIdx) {\n      postDoomedGroupby.push(col);\n    }\n  });\n\n  return [lastGroupIsDoomed, preDoomedGroupby, postDoomedGroupby];\n}\n\n// hardcode the index ref for now\n// When we build the group index, all groups are collapsed\nexport function indexGroupedRows(groupedRows) {\n  // TODO\n  const Fields = {\n    Depth: 1,\n    Key: 4\n  };\n\n  const groupedIndex = {};\n  const levels = [];\n  const COLLAPSED = -1;\n\n  for (let idx = 0; idx < groupedRows.length; idx++) {\n    let row = groupedRows[idx];\n    let rowDepth = row[Fields.Depth];\n\n    if (rowDepth === 0) {\n      let index = [idx];\n      levels.forEach((level) => {\n        index.push(level[1], COLLAPSED);\n      });\n      groupedIndex[row[Fields.Key]] = index;\n    } else {\n      while (levels.length && Math.abs(levels[levels.length - 1][0]) <= Math.abs(rowDepth)) {\n        levels.pop();\n      }\n      levels.push([rowDepth, idx]);\n    }\n  }\n\n  return groupedIndex;\n}\n\n/** @type {import('./group-utils').findAggregatedColumns} */\nexport function findAggregatedColumns(columns, columnMap, groupby) {\n  return columns.reduce((aggregations, column) => {\n    if (column.aggregate && indexOfCol(column.name, groupby) === -1) {\n      const key = columnMap[column.name];\n      aggregations.push([key, column.aggregate]);\n    }\n    return aggregations;\n  }, []);\n}\n\n/**\n * Called when we clear a filter\n *\n * @type {import('./group-utils').aggregateGroup} */\nexport function aggregateGroup(groups, grpIdx, sortSet, rows, columns, aggregations, maxDepth) {\n  const groupRow = groups[grpIdx];\n  let depth = groupRow[DEPTH];\n  let absDepth = Math.abs(depth);\n  let count = 0;\n  let idx = grpIdx;\n\n  // find the last nested group and work back - first build aggregates for level 1 groups,\n  // then use those to aggregate to level 2 etc.\n  while (idx < groups.length - 1 && Math.abs(groups[idx + 1][DEPTH]) < absDepth) {\n    idx += 1;\n    count += 1;\n  }\n\n  for (let i = grpIdx + count; i >= grpIdx; i--) {\n    for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n      const [colIdx] = aggregations[aggIdx];\n      const dataIdx = colIdx + metadataOffset - 2; // <<<<<<<<<<<\n      groups[i][dataIdx] = 0;\n    }\n    aggregate(groups[i], groups, sortSet, rows, aggregations, maxDepth, groups[i][COUNT]);\n  }\n}\n\nfunction aggregate(\n  groupRow,\n  groupRows,\n  sortSet,\n  rows,\n  aggregations,\n  maxDepth,\n  leafCount,\n  filter = null\n) {\n  let depth = groupRow[DEPTH];\n  let count = 0;\n  let filteredCount = filter === null ? undefined : 0;\n\n  if (depth === maxDepth) {\n    // The first group accumulates aggregates from the raw data...\n    let start = groupRow[IDX_POINTER];\n    let end = start + leafCount;\n    count = leafCount;\n    for (let i = start; i < end; i++) {\n      const row = rows[sortSet[i]];\n      const included = filter === null || filter(row);\n      if (filter && included) {\n        filteredCount += 1;\n      }\n      if (filter === null || included) {\n        for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n          const [colIdx] = aggregations[aggIdx];\n          groupRow[metadataOffset + colIdx - 2 /* !!!!!!! */] += row[colIdx];\n        }\n      }\n    }\n  } else {\n    // higher-level groups aggregate from child-groups ...\n    // we cannot blindly use the grpIndex of the groupRow, as we may be dealing with a smaller subset\n    // of groupRows, e,g, when inserting a new row and creating the missing groups\n    const startIdx = groupRows.indexOf(groupRow) + 1;\n    for (let i = startIdx; i < groupRows.length; i++) {\n      const nestedGroupRow = groupRows[i];\n      const nestedRowDepth = nestedGroupRow[DEPTH];\n      const nestedRowCount = nestedGroupRow[COUNT];\n      const absNestedRowDepth = Math.abs(nestedRowDepth);\n      if (absNestedRowDepth >= depth) {\n        break;\n      } else if (absNestedRowDepth === depth - 1) {\n        for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n          const [colIdx, method] = aggregations[aggIdx];\n          if (method === 'avg') {\n            groupRow[metadataOffset + colIdx - 2] +=\n              nestedGroupRow[metadataOffset + colIdx - 2] * nestedRowCount;\n          } else {\n            groupRow[metadataOffset + colIdx - 2] += nestedGroupRow[metadataOffset + colIdx - 2];\n          }\n        }\n        count += nestedRowCount;\n      }\n    }\n  }\n\n  for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n    const [colIdx, method] = aggregations[aggIdx];\n    if (method === 'avg') {\n      groupRow[metadataOffset + colIdx - 2] = groupRow[metadataOffset + colIdx - 2] / count;\n    }\n  }\n\n  groupRow[COUNT] = count;\n  groupRow[FILTER_COUNT] = filteredCount;\n}\n\nexport function leafRow(groupKey, [idx, key, ...data]) {\n  // TODO find fastest way to do this\n  const row = Array(metadataOffset).fill(0).concat(data);\n  row[IDX] = idx;\n  row[KEY] = `${groupKey}${GROUP_KEY_DELIMITER}${key}`;\n  row[IS_LEAF] = true;\n  return row;\n}\n", "export const NULL_RANGE = { lo: 0, hi: 0 };\n\n// If the requested range overlaps the last sent range, we only need send the\n// newly exposed section of the range. The client will manage dropping off\n// the expired section.\n//\n// |----------------------------------| _range\n//  ++++++|----------------------------------| prevRange\n//\n//\n//\n//  |------------------------------------| _range\n//  |----------------------------------|+  prevRange\n\n/** @type {import('./range-utils').getDeltaRange} */\nexport function getDeltaRange(oldRange, newRange) {\n  //TODO do we still need these calls to getFullRange ?\n  const { lo: oldLo, hi: oldHi } = oldRange; /*getFullRange(oldRange)*/\n  const { lo: newLo, hi: newHi } = newRange; /*getFullRange(newRange)*/\n\n  if (newLo >= oldLo && newHi <= oldHi) {\n    // reduced range, no delta\n    return { from: newHi, to: newHi };\n  } else if (newLo >= oldHi || newHi < oldLo) {\n    return { from: newLo, to: newHi };\n  } else if (newLo === oldLo && newHi === oldHi) {\n    return { from: oldHi, to: oldHi };\n  } else {\n    return {\n      from: newLo < oldLo ? newLo : oldHi,\n      to: newHi > oldHi ? newHi : oldLo\n    };\n  }\n}\n\n/**\n *\n * @type {import('./range-utils').resetRange}\n */\nexport function resetRange({ lo, hi, bufferSize = 0 }) {\n  return {\n    lo: 0,\n    hi: hi - lo,\n    bufferSize,\n    reset: true\n  };\n}\n\nconst SAME = 0;\nconst FWD = 2;\nconst BWD = 4;\nconst CONTIGUOUS = 8;\nconst OVERLAP = 16;\nconst REDUCE = 32;\nconst EXPAND = 64;\nconst NULL = 128;\n\nexport const RangeFlags = {\n  SAME,\n  FWD,\n  BWD,\n  CONTIGUOUS,\n  OVERLAP,\n  REDUCE,\n  EXPAND,\n  NULL\n};\n\nRangeFlags.GAP = ~(CONTIGUOUS | OVERLAP | REDUCE);\n\n/** @type {import('./range-utils').compareRanges} */\nexport function compareRanges(range1, range2) {\n  if (range2.lo === 0 && range2.hi === 0) {\n    return NULL;\n  } else if (range1.lo === range2.lo && range1.hi === range2.hi) {\n    return SAME;\n  } else if (range2.hi > range1.hi) {\n    if (range2.lo > range1.hi) {\n      return FWD;\n    } else if (range2.lo === range1.hi) {\n      return FWD + CONTIGUOUS;\n    } else if (range2.lo >= range1.lo) {\n      return FWD + OVERLAP;\n    } else {\n      return EXPAND;\n    }\n  } else if (range2.lo < range1.lo) {\n    if (range2.hi < range1.lo) {\n      return BWD;\n    } else if (range2.hi === range1.lo) {\n      return BWD + CONTIGUOUS;\n    } else if (range2.hi > range1.lo) {\n      return BWD + OVERLAP;\n    } else {\n      return EXPAND;\n    }\n  } else if (range2.lo > range1.lo) {\n    return REDUCE + FWD;\n  } else {\n    return REDUCE + BWD;\n  }\n}\n", "/**\n * Keep all except for groupRowset in this file to avoid circular reference warnings\n */\nimport * as d3 from 'd3-array';\nimport Table from '../table';\nimport SelectionModel, { SelectionModelType } from '../selection-model';\nimport { sort, sortExtend, sortReversed, sortBy, sortPosition, sortableFilterSet } from '../sort';\nimport { groupbyExtendsExistingGroupby } from '../group-utils';\nimport {\n  addRowsToIndex,\n  arrayOfIndices,\n  BIN_FILTER_DATA_COLUMNS,\n  DataTypes,\n  extendsFilter,\n  extractFilterForColumn,\n  functor as filterPredicate,\n  getFullRange,\n  projectColumns,\n  projectUpdates,\n  mapSortCriteria,\n  metadataKeys,\n  overrideColName,\n  SET_FILTER_DATA_COLUMNS,\n  splitFilterOnColumn\n} from '@vuu-ui/utils';\nimport { getDeltaRange, NULL_RANGE } from '../range-utils';\n\nconst SINGLE_COLUMN = 1;\n\nconst NO_OPTIONS = {\n  filter: null\n};\n\nexport default class BaseRowSet {\n  constructor(table, offset = 0, range = NULL_RANGE) {\n    this.table = table;\n    this.offset = offset;\n    this.baseOffset = offset;\n    this.range = range;\n    this.currentFilter = null;\n    this.filterSet = null;\n    this.sortSet = undefined;\n    this.data = table.rows;\n    this.type = undefined;\n    this.index = undefined;\n    this.selectedRowsIDX = [];\n  }\n\n  get size() {\n    console.error('size must be implemented by concrete Rowset');\n    return 0;\n  }\n\n  slice() {\n    throw new Error('slice must be implemented by concrete Rowset');\n  }\n\n  // used by binned rowset\n  get filteredData() {\n    if (this.filterSet) {\n      return this.filterSet;\n    } else {\n      const { IDX } = metadataKeys;\n      return this.data.map((row) => row[IDX]);\n    }\n  }\n\n  get stats() {\n    // TODO cache the stats and invalidate them in the event of any op that might change them\n    const { totalRowCount, filteredRowCount, selectedRowsIDX } = this;\n    const totalSelected = selectedRowsIDX.length;\n    // const filteredSelected = selected.rows.length;\n    const filteredSelected = 0;\n\n    return {\n      totalRowCount,\n      totalSelected,\n      filteredRowCount,\n      filteredSelected\n    };\n  }\n\n  get totalRowCount() {\n    return this.data.length;\n  }\n\n  get filteredRowCount() {\n    return this.filterSet === null ? this.data.length : this.filterSet.length;\n  }\n\n  get selectedRowCount() {\n    return this.selectedRowsIDX.length;\n  }\n\n  setRange(range = this.range, useDelta = true, includeStats = false) {\n    const { from, to } = useDelta ? getDeltaRange(this.range, range) : getFullRange(range);\n    const resultset = this.slice(from, to);\n    this.range = range;\n    const length = this.size;\n    return {\n      dataType: this.type,\n      rows: resultset,\n      range,\n      size: length,\n      offset: this.offset,\n      stats: includeStats ? this.stats : undefined\n    };\n  }\n\n  currentRange() {\n    const { lo, hi } = this.range;\n    const resultset = this.slice(lo, hi);\n    return {\n      dataType: this.type,\n      rows: resultset,\n      range: this.range,\n      size: this.size,\n      offset: this.offset,\n      stats: undefined\n    };\n  }\n\n  select(selectedIndices) {\n    // TODO work out the changed rows so we can return the correct updates\n\n    const {\n      range: { lo, hi },\n      filterSet,\n      sortSet\n    } = this;\n\n    console.log({ lo, hi, sortSet, filterSet });\n\n    // assuming no filterSet\n    const idxToIDX = (idx) => sortSet[idx][0];\n    this.selectedRowsIDX = selectedIndices.map(idxToIDX);\n    return this.currentRange();\n\n    // if (filterSet){\n    //     if (selectedIndices.length){\n    //         this.selectedRowsIDX.push(...selected.map(i => filterSet[i]))\n    //     }\n    //     if (deselected.length){\n    //         const deselectedRowIDX = deselected.map(i => filterSet[i]);\n    //         this.selectedRowsIDX = this.selectedRowsIDX.filter(rowIdx => !deselectedRowIDX.includes(rowIdx));\n    //     }\n    // } else {\n    // const idxToIDX = idx => sortSet[idx][0];\n    // this.selectedRowsIDX = this.selected.rows.map(idxToIDX)\n    // }\n\n    // const updates = [];\n    // for (let i=0;i<selected.length;i++){\n    //     const idx = selected[i];\n    //     if (idx >= lo && idx < hi){\n    //         updates.push([idx+offset,SELECTED, 1]);\n    //     }\n    // }\n    // for (let i=0;i<deselected.length;i++){\n    //     const idx = deselected[i];\n    //     if (idx >= lo && idx < hi){\n    //         updates.push([idx+offset,SELECTED, 0]);\n    //     }\n    // }\n\n    // return updates;\n  }\n\n  selectAll() {\n    const {\n      data,\n      selected,\n      selectedRowsIDX,\n      range: { lo, hi },\n      filterSet,\n      offset\n    } = this;\n    const { SELECTED } = metadataKeys;\n    const previouslySelectedRows = [...this.selected.rows];\n    if (filterSet) {\n      // selection of a filtered subset is added to existing selection\n      for (let i = 0; i < filterSet.length; i++) {\n        const rowIDX = filterSet[i];\n        if (!selectedRowsIDX.includes(rowIDX)) {\n          selected.rows.push(i); // does it matter if thes eend up out of sequence ?\n          selectedRowsIDX.push(rowIDX);\n        }\n      }\n    } else {\n      // Step 1: brute force approach, actually create list of selected indices\n      // need to replace this with a structure that tracks ranges\n      this.selected = { rows: arrayOfIndices(data.length), focusedIdx: -1, lastTouchIdx: -1 };\n      this.selectedRowsIDX = [...this.selected.rows];\n    }\n\n    const updates = [];\n    const max = Math.min(hi, (filterSet || data).length);\n    for (let i = lo; i < max; i++) {\n      if (this.selected.rows.includes(i) && !previouslySelectedRows.includes(i)) {\n        updates.push([i + offset, SELECTED, 1]);\n      }\n    }\n\n    return updates;\n  }\n\n  selectNone() {\n    const {\n      range: { lo, hi },\n      filterSet,\n      offset\n    } = this;\n    const { SELECTED } = metadataKeys;\n    const previouslySelectedRows = this.selectedRowsIDX;\n    if (filterSet) {\n      this.selected = { rows: [], focusedIdx: -1, lastTouchIdx: -1 };\n      this.selectedRowsIDX = this.selectedRowsIDX.filter((idx) => !filterSet.includes(idx));\n    } else {\n      this.selected = { rows: [], focusedIdx: -1, lastTouchIdx: -1 };\n      this.selectedRowsIDX = [];\n    }\n    const updates = [];\n    for (let i = lo; i < hi; i++) {\n      const idx = filterSet ? filterSet[i] : i;\n      if (previouslySelectedRows.includes(idx)) {\n        updates.push([i + offset, SELECTED, 0]);\n      }\n    }\n    return updates;\n  }\n\n  selectNavigationSet(useFilter) {\n    const { COUNT, IDX_POINTER, FILTER_COUNT, NEXT_FILTER_IDX } = metadataKeys;\n    return useFilter\n      ? [this.filterSet, NEXT_FILTER_IDX, FILTER_COUNT]\n      : [this.sortSet, IDX_POINTER, COUNT];\n  }\n\n  //TODO cnahge to return a rowSet, same as getDistinctValuesForColumn\n  getBinnedValuesForColumn(column) {\n    const key = this.table.columnMap[column.name];\n    const { data: rows, filteredData } = this;\n    const numbers = filteredData.map((rowIdx) => rows[rowIdx][key]);\n    const data = d3\n      .histogram()\n      .thresholds(20)(numbers)\n      .map((arr, i) => [i + 1, arr.length, arr.x0, arr.x1]);\n\n    const table = new Table({ data, primaryKey: 'bin', columns: BIN_FILTER_DATA_COLUMNS });\n    const filterRowset = new BinFilterRowSet(table, BIN_FILTER_DATA_COLUMNS, column.name);\n    return filterRowset;\n  }\n\n  getDistinctValuesForColumn(column) {\n    const { data: rows, currentFilter } = this;\n    const colIdx = this.table.columnMap[column.name];\n    const resultMap = {};\n    const data = [];\n    const dataRowCount = rows.length;\n    const [, /*columnFilter*/ otherFilters] = splitFilterOnColumn(currentFilter, column);\n    // this filter for column that we remove will provide our selected values\n    let dataRowAllFilters = 0;\n\n    if (otherFilters === null) {\n      let result;\n      for (let i = 0; i < dataRowCount; i++) {\n        const val = rows[i][colIdx];\n        // eslint-disable-next-line no-cond-assign\n        if ((result = resultMap[val])) {\n          result[2] = ++result[1];\n        } else {\n          result = [val, 1, 1];\n          resultMap[val] = result;\n          data.push(result);\n        }\n      }\n      dataRowAllFilters = dataRowCount;\n    } else {\n      const fn = filterPredicate(this.table.columnMap, otherFilters);\n      let result;\n\n      for (let i = 0; i < dataRowCount; i++) {\n        const row = rows[i];\n        const val = row[colIdx];\n        const isIncluded = fn(row) ? 1 : 0;\n        // eslint-disable-next-line no-cond-assign\n        if ((result = resultMap[val])) {\n          result[1] += isIncluded;\n          result[2]++;\n        } else {\n          result = [val, isIncluded, 1];\n          resultMap[val] = result;\n          data.push(result);\n        }\n        dataRowAllFilters += isIncluded;\n      }\n    }\n\n    //TODO primary key should be indicated in columns\n    const table = new Table({ data, primaryKey: 'name', columns: SET_FILTER_DATA_COLUMNS });\n    return new SetFilterRowSet(\n      table,\n      SET_FILTER_DATA_COLUMNS,\n      column.name,\n      dataRowAllFilters,\n      dataRowCount\n    );\n  }\n}\n\n//TODO should range be baked into the concept of RowSet ?\nexport class RowSet extends BaseRowSet {\n  // TODO stream as above\n  static fromGroupRowSet({ table, columns, offset, currentFilter: filter }) {\n    return new RowSet(table, columns, offset, {\n      filter\n    });\n  }\n  //TODO consolidate API of rowSet, groupRowset\n  constructor(table, columns, offset = 0, { filter = null } = NO_OPTIONS) {\n    super(table, offset);\n    this.type = 'rowData';\n    this.project = projectColumns(table.columnMap, columns);\n    this.sortCols = null;\n    this.sortReverse = false;\n    this.sortSet = this.buildSortSet();\n    this.filterSet = null;\n    this.sortRequired = false;\n    if (filter) {\n      this.currentFilter = filter;\n      this.filter(filter);\n    }\n  }\n\n  buildSortSet() {\n    const len = this.data.length;\n    const arr = Array(len);\n    for (let i = 0; i < len; i++) {\n      arr[i] = [i, null, null]; // so we're allowing max of 2 sort criteria ?\n    }\n    return arr;\n  }\n\n  slice(lo, hi) {\n    const { data, selectedRowsIDX, filterSet, offset, sortCols, sortSet, sortReverse } = this;\n    if (filterSet) {\n      const filterMapper =\n        typeof filterSet[0] === 'number' ? (idx) => data[idx] : ([idx]) => data[idx];\n\n      const results = [];\n      for (let i = lo, len = filterSet.length; i < len && i < hi; i++) {\n        const row = sortReverse ? filterMapper(filterSet[len - i - 1]) : filterMapper(filterSet[i]);\n        results.push(row);\n      }\n      return results.map(this.project(lo, offset, selectedRowsIDX));\n    } else if (sortCols) {\n      const results = [];\n      for (let i = lo, len = data.length; i < len && i < hi; i++) {\n        const idx = sortReverse ? sortSet[len - i - 1][0] : sortSet[i][0];\n        const row = data[idx];\n        results.push(row);\n      }\n      return results.map(this.project(lo, offset, selectedRowsIDX));\n    } else {\n      return this.data.slice(lo, hi).map(this.project(lo, offset, selectedRowsIDX));\n    }\n  }\n\n  // deprecated ?\n  get size() {\n    return this.filterSet === null ? this.data.length : this.filterSet.length;\n  }\n\n  get first() {\n    return this.data[0];\n  }\n  get last() {\n    return this.data[this.data.length - 1];\n  }\n  get rawData() {\n    return this.data;\n  }\n\n  setSubscribedColumns(columns) {\n    console.log(`Rowset setSubscribedColumns ${columns.join(',')}`);\n  }\n\n  setStatus(status) {\n    this.status = status;\n  }\n\n  addRows(rows) {\n    // TODO where is this.index ever created ?\n    addRowsToIndex(rows, this.index, metadataKeys.IDX);\n    this.data = this.data.concat(rows);\n  }\n\n  sort(sortCols) {\n    const sortSet =\n      this.currentFilter === null\n        ? this.sortSet\n        : (this.filterSet = sortableFilterSet(this.filterSet));\n\n    this.sortRequired = this.currentFilter !== null;\n\n    if (sortReversed(this.sortCols, sortCols, SINGLE_COLUMN)) {\n      this.sortReverse = !this.sortReverse;\n    } else if (this.sortCols !== null && groupbyExtendsExistingGroupby(sortCols, this.sortCols)) {\n      this.sortReverse = false;\n      sortExtend(sortSet, this.data, sortCols, this.table.columnMap);\n    } else {\n      this.sortReverse = false;\n      sort(sortSet, this.data, sortCols, this.table.columnMap);\n    }\n\n    this.sortCols = sortCols;\n  }\n\n  clearFilter() {\n    this.currentFilter = null;\n    this.filterSet = null;\n    if (this.sortRequired) {\n      this.sort(this.sortCols);\n    }\n  }\n\n  filter(filter) {\n    const extendsCurrentFilter = extendsFilter(this.currentFilter, filter);\n    const fn = filter && filterPredicate(this.table.columnMap, filter);\n    const { data: rows } = this;\n    let [navSet] = this.selectNavigationSet(extendsCurrentFilter && this.filterSet);\n    const newFilterSet = [];\n\n    for (let i = 0; i < navSet.length; i++) {\n      const rowIdx = navSet === this.filterSet ? navSet[i] : navSet[i][0];\n      const row = rows[rowIdx];\n      if (fn(row)) {\n        newFilterSet.push(rowIdx);\n      }\n    }\n\n    // recompute selected.rows from selectedRowIDX\n    if (this.selectedRowsIDX.length) {\n      const { selectedRowsIDX, selected } = this;\n      selected.rows.length = 0;\n      for (let i = 0; i < newFilterSet.length; i++) {\n        const rowIDX = newFilterSet[i];\n        if (selectedRowsIDX.includes(rowIDX)) {\n          selected.rows.push(i);\n        }\n      }\n    }\n\n    this.filterSet = newFilterSet;\n    this.currentFilter = filter;\n    if (!extendsCurrentFilter && this.sortRequired) {\n      // TODO this might be very expensive for large dataset\n      // WHEN DO WE DO THIS - IS THIS CORRECT !!!!!\n      this.sort(this.sortCols);\n    }\n    return newFilterSet.length;\n  }\n\n  update(idx, updates) {\n    if (this.currentFilter === null && this.sortCols === null) {\n      if (idx >= this.range.lo && idx < this.range.hi) {\n        return [idx + this.offset, ...projectUpdates(updates)];\n      }\n    } else if (this.currentFilter === null) {\n      const { sortSet } = this;\n      for (let i = this.range.lo; i < this.range.hi; i++) {\n        const [rowIdx] = sortSet[i];\n        if (rowIdx === idx) {\n          return [i + this.offset, ...projectUpdates(updates)];\n        }\n      }\n    } else {\n      // sorted AND/OR filtered\n      const { filterSet } = this;\n      for (let i = this.range.lo; i < this.range.hi; i++) {\n        const rowIdx = Array.isArray(filterSet[i]) ? filterSet[i][0] : filterSet[i];\n        if (rowIdx === idx) {\n          return [i + this.offset, ...projectUpdates(updates)];\n        }\n      }\n    }\n  }\n\n  insert(idx, row) {\n    // TODO multi colun sort sort DSC\n    if (this.sortCols === null && this.currentFilter === null) {\n      // simplest scenario, row will be at end of sortset ...\n      this.sortSet.push([idx, null, null]);\n      if (idx >= this.range.hi) {\n        // ... row is beyond viewport\n        return {\n          size: this.size\n        };\n      } else {\n        // ... row is within viewport\n        return {\n          size: this.size,\n          replace: true\n        };\n      }\n    } else if (this.currentFilter === null) {\n      // sort only - currently only support single column sorting\n      const sortCols = mapSortCriteria(this.sortCols, this.table.columnMap);\n      const [[colIdx]] = sortCols;\n      const sortRow = [idx, row[colIdx]];\n      const sorter = sortBy([[1, 'asc']]); // the sortSet is always ascending\n      const sortPos = sortPosition(this.sortSet, sorter, sortRow, 'last-available');\n      this.sortSet.splice(sortPos, 0, sortRow);\n\n      // we need to know whether it is an ASC or DSC sort to determine whether row is in viewport\n      const viewportPos = this.sortReverse ? this.size - sortPos : sortPos;\n\n      if (viewportPos >= this.range.hi) {\n        return {\n          size: this.size\n        };\n      } else if (viewportPos >= this.range.lo) {\n        return {\n          size: this.size,\n          replace: true\n        };\n      } else {\n        return {\n          size: this.size,\n          offset: this.offset - 1\n        };\n      }\n    } else if (this.sortCols === null) {\n      // filter only\n      const fn = filterPredicate(this.table.columnMap, this.currentFilter);\n      if (fn(row)) {\n        const navIdx = this.filterSet.length;\n        this.filterSet.push(idx);\n        if (navIdx >= this.range.hi) {\n          // ... row is beyond viewport\n          return {\n            size: this.size\n          };\n        } else if (navIdx >= this.range.lo) {\n          // ... row is within viewport\n          return {\n            size: this.size,\n            replace: true\n          };\n        } else {\n          return {\n            size: this.size,\n            offset: this.offset - 1\n          };\n        }\n      } else {\n        return {};\n      }\n    } else {\n      // sort AND filter\n      const fn = filterPredicate(this.table.columnMap, this.currentFilter);\n      if (fn(row)) {\n        // TODO what about totalCOunt\n\n        const sortCols = mapSortCriteria(this.sortCols, this.table.columnMap);\n        const [[colIdx, direction]] = sortCols; // TODO multi-colun sort\n        const sortRow = [idx, row[colIdx]];\n        const sorter = sortBy([[1, direction]]); // TODO DSC\n        const navIdx = sortPosition(this.filterSet, sorter, sortRow, 'last-available');\n        this.filterSet.splice(navIdx, 0, sortRow);\n\n        if (navIdx >= this.range.hi) {\n          // ... row is beyond viewport\n          return {\n            size: this.size\n          };\n        } else if (navIdx >= this.range.lo) {\n          // ... row is within viewport\n          return {\n            size: this.size,\n            replace: true\n          };\n        } else {\n          return {\n            size: this.size,\n            offset: this.offset - 1\n          };\n        }\n      } else {\n        return {};\n      }\n    }\n  }\n}\n\n// TODO need to retain and return any searchText\nexport class SetFilterRowSet extends RowSet {\n  constructor(table, columns, columnName, dataRowAllFilters, dataRowTotal) {\n    super(table, columns);\n    this.type = DataTypes.FILTER_DATA;\n    this.columnName = columnName;\n    this._searchText = null;\n    this.dataRowFilter = null;\n    this.dataCounts = {\n      dataRowTotal,\n      dataRowAllFilters,\n      dataRowCurrentFilter: 0,\n      filterRowTotal: this.data.length,\n      filterRowSelected: this.data.length,\n      filterRowHidden: 0\n    };\n    this.sort([['name', 'asc']]);\n  }\n\n  createSelectionModel() {\n    return new SelectionModel(SelectionModelType.Checkbox);\n  }\n\n  clearRange() {\n    this.range = { lo: 0, hi: 0 };\n  }\n\n  get values() {\n    const key = this.table.columnMap['name'];\n    return this.filterSet.map((idx) => this.data[idx][key]);\n  }\n\n  // will we ever need this on base rowset ?\n  getSelectedValue(idx) {\n    const { data, sortSet, filterSet } = this;\n    if (filterSet) {\n      const filterEntry = filterSet[idx];\n      const rowIDX = typeof filterEntry === 'number' ? filterEntry : filterEntry[0];\n      return data[rowIDX][0];\n    } else {\n      return sortSet[idx][1];\n    }\n  }\n\n  setSelectedFromFilter(dataRowFilter) {\n    const columnFilter = extractFilterForColumn(dataRowFilter, this.columnName);\n    const columnMap = this.table.columnMap;\n    const { data, filterSet, sortSet } = this;\n\n    this.dataRowFilter = dataRowFilter;\n\n    if (columnFilter) {\n      const fn = filterPredicate(columnMap, overrideColName(columnFilter, 'name'));\n      const selectedRows = [];\n      const selectedRowsIDX = [];\n\n      if (filterSet) {\n        for (let i = 0; i < filterSet.length; i++) {\n          const rowIDX = filterSet[i];\n          if (fn(data[rowIDX])) {\n            selectedRows.push(i);\n            selectedRowsIDX.push(rowIDX);\n          }\n        }\n      } else {\n        for (let i = 0; i < data.length; i++) {\n          const rowIDX = sortSet[i][0];\n          if (fn(data[rowIDX])) {\n            selectedRows.push(i);\n            selectedRowsIDX.push(rowIDX);\n          }\n        }\n      }\n\n      this.selected = { rows: selectedRows, focusedIdx: -1, lastTouchIdx: -1 };\n      this.selectedRowsIDX = selectedRowsIDX;\n    } else {\n      this.selectAll();\n    }\n\n    return this.currentRange();\n  }\n}\n\nexport class BinFilterRowSet extends RowSet {\n  constructor(table, columns, columnName) {\n    super(table, columns);\n    this.type = DataTypes.FILTER_BINS;\n    this.columnName = columnName;\n  }\n\n  setSelectedFromFilter(filter) {\n    console.log(`need to apply filter to selected BinRowset`, filter);\n  }\n  // we don't currently have a concept of range here, but it will\n  // be used in the future\n  // Note: currently no projection here, we don't currently need metadata\n  setRange() {\n    const length = this.size;\n    return {\n      dataType: this.type,\n      rows: this.data,\n      range: null,\n      size: length,\n      offset: 0,\n      stats: undefined\n    };\n  }\n}\n", "import { getFullRange, metadataKeys } from '@vuu-ui/utils';\nimport { NULL_RANGE, compareRanges, RangeFlags, getDeltaRange } from './range-utils';\nimport { getCount, leafRow } from './group-utils';\n\nconst RANGE_POS_TUPLE_SIZE = 4;\nconst NO_RESULT = [null, null, null];\nconst { IS_EXPANDED, DEPTH, KEY, PARENT_IDX } = metadataKeys;\n\nexport const FORWARDS = 0;\nexport const BACKWARDS = 1;\n\nexport default function GroupIterator(groups, groupBy, navSet, data, NAV_IDX, NAV_COUNT) {\n  let _idx = 0;\n  let _grpIdx = null;\n  let _rowIdx = null;\n  let _direction = FORWARDS;\n  let _range = NULL_RANGE;\n  let _range_position_lo = [0, null, null];\n  let _range_positions = [];\n  // eslint-disable-next-line no-unused-vars\n  let _range_position_hi = [null, null, null];\n  let groupCount = groupBy.length;\n\n  return {\n    get direction() {\n      return _direction;\n    },\n    get rangePositions() {\n      return _range_positions;\n    }, // do we ever use these ?\n    setRange,\n    currentRange,\n    getRangeIndexOfGroup,\n    getRangeIndexOfRow,\n    setNavSet,\n    setGroupCount,\n    refresh: currentRange,\n    clear\n  };\n\n  function setGroupCount(value) {\n    groupCount = value;\n  }\n\n  function getRangeIndexOfGroup(grpIdx) {\n    const list = _range_positions;\n    for (let i = 0; i < list.length; i += RANGE_POS_TUPLE_SIZE) {\n      if (list[i + 1] === grpIdx) {\n        if (list[i + 2] === null) {\n          return i / RANGE_POS_TUPLE_SIZE;\n        } else {\n          // first row encountere should be the group, if it\n          // isn't it means it is crolled out of viewport\n          return -1;\n        }\n      }\n    }\n    return -1;\n  }\n\n  function getRangeIndexOfRow(idx) {\n    const list = _range_positions;\n    for (let i = 0; i < list.length; i += RANGE_POS_TUPLE_SIZE) {\n      if (list[i + 3] === idx) {\n        return i / RANGE_POS_TUPLE_SIZE;\n      }\n    }\n    return -1;\n  }\n\n  function clear() {\n    _idx = 0;\n    _grpIdx = null;\n    _rowIdx = null;\n    _direction = FORWARDS;\n    _range = NULL_RANGE;\n    _range_position_lo = [0, null, null];\n    _range_positions = [];\n    _range_position_hi = [null, null, null];\n  }\n\n  function setNavSet([newNavSet, navIdx, navCount]) {\n    navSet = newNavSet;\n    NAV_IDX = navIdx;\n    NAV_COUNT = navCount;\n  }\n\n  function currentRange() {\n    /** @type {import('./group-iterator').RowsIndexTuple} */\n    const result = [[], null];\n    const [rows] = result;\n\n    const { IDX } = metadataKeys;\n    [_idx, _grpIdx, _rowIdx] = _range_position_lo;\n    if (_idx === 0 && _grpIdx === null && _rowIdx === null) {\n      _idx = -1;\n    }\n    _range_positions.length = 0;\n\n    let startIdx = _idx;\n    let row;\n    let i = _range.lo;\n    do {\n      _direction = FORWARDS;\n      [row, _grpIdx, _rowIdx] = next(\n        groups,\n        groupCount,\n        data,\n        _grpIdx,\n        _rowIdx,\n        navSet,\n        NAV_IDX,\n        NAV_COUNT\n      );\n      if (row) {\n        rows.push(row);\n        _idx += 1;\n        const absRowIdx = _rowIdx === null ? null : row[IDX];\n        _range_positions.push(_idx, _grpIdx, _rowIdx, absRowIdx);\n        i += 1;\n      }\n    } while (row && i < _range.hi);\n    if (row) {\n      _direction = FORWARDS;\n      const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n      [row, _grpIdx, _rowIdx] = next(\n        groups,\n        groupCount,\n        data,\n        _grpIdx,\n        _rowIdx,\n        navSet,\n        NAV_IDX,\n        NAV_COUNT\n      );\n      _idx += 1;\n      _range_position_hi = [row ? _idx : null, _grpIdx, _rowIdx];\n      [_grpIdx, _rowIdx] = [grpIdx, rowIdx];\n    } else {\n      _range_position_hi = [null, null, null];\n    }\n\n    result[1] = startIdx + 1;\n    return result;\n  }\n\n  function setRange(range, useDelta = true) {\n    const rangeDiff = compareRanges(_range, range);\n    const { from: resultLo, to: resultHi } = useDelta\n      ? getDeltaRange(_range, range)\n      : getFullRange(range);\n    const { IDX } = metadataKeys;\n\n    /** @type {import('./group-iterator').RowsIndexTuple} */\n    const result = [[], null];\n    const [rows] = result;\n\n    if (rangeDiff === RangeFlags.NULL) {\n      _range_position_lo = [0, null, null];\n      _range_position_hi = [null, null, null];\n      _range_positions.length = 0;\n      return result;\n    } else if (range.lo === _range.lo && useDelta === false) {\n      // when we're asked for the same range again, rebuild the range\n      [_idx, _grpIdx, _rowIdx] = _range_position_lo;\n      _range_positions.length = 0;\n    } else {\n      if (_direction === FORWARDS && rangeDiff & RangeFlags.BWD) {\n        [_idx, _grpIdx, _rowIdx] = _range_positions;\n      } else if (_direction === BACKWARDS && rangeDiff & RangeFlags.FWD) {\n        [_idx, _grpIdx, _rowIdx] = _range_positions.slice(-RANGE_POS_TUPLE_SIZE);\n        _idx += 1;\n      }\n\n      if (rangeDiff === RangeFlags.FWD) {\n        skip(range.lo - _range.hi, next);\n        _range_positions.length = 0;\n      } else if (rangeDiff === RangeFlags.BWD) {\n        skip(_range.lo - range.hi, previous);\n        _range_positions.length = 0;\n      }\n\n      const loDiff = range.lo - _range.lo;\n      const hiDiff = _range.hi - range.hi;\n      // allow for a range that overshoots data\n      const missingQuota = _range.hi - _range.lo - _range_positions.length / RANGE_POS_TUPLE_SIZE;\n\n      if (loDiff > 0) {\n        const removed = _range_positions.splice(0, loDiff * RANGE_POS_TUPLE_SIZE);\n        if (removed.length) {\n          _range_position_lo = removed.slice(-RANGE_POS_TUPLE_SIZE);\n\n          // experiment - is this A) always correct B) enough\n          if (useDelta === false) {\n            [_idx, _grpIdx, _rowIdx] = _range_position_lo;\n          }\n        }\n      }\n      if (hiDiff > 0) {\n        //TODO allow for scenatio where both lo and HI have changed\n        if (hiDiff > missingQuota) {\n          const absDiff = hiDiff - missingQuota;\n          const removed = _range_positions.splice(\n            -absDiff * RANGE_POS_TUPLE_SIZE,\n            absDiff * RANGE_POS_TUPLE_SIZE\n          );\n          if (removed.length) {\n            _range_position_hi = removed.slice(0, RANGE_POS_TUPLE_SIZE);\n          }\n        }\n      }\n    }\n\n    let row;\n    let startIdx = null;\n\n    if ((rangeDiff & RangeFlags.REDUCE) === 0) {\n      if (rangeDiff & RangeFlags.FWD || rangeDiff === RangeFlags.SAME) {\n        let i = resultLo;\n        startIdx = _idx;\n        do {\n          _direction = FORWARDS;\n          [row, _grpIdx, _rowIdx] = next(\n            groups,\n            groupCount,\n            data,\n            _grpIdx,\n            _rowIdx,\n            navSet,\n            NAV_IDX,\n            NAV_COUNT\n          );\n          if (row) {\n            rows.push(row);\n            const absRowIdx = _rowIdx === null ? null : row[IDX];\n            _range_positions.push(_idx, _grpIdx, _rowIdx, absRowIdx);\n            i += 1;\n            _idx += 1;\n          }\n        } while (row && i < resultHi);\n        if (row) {\n          _direction = FORWARDS;\n          const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n          [row, _grpIdx, _rowIdx] = next(\n            groups,\n            groupCount,\n            data,\n            _grpIdx,\n            _rowIdx,\n            navSet,\n            NAV_IDX,\n            NAV_COUNT\n          );\n          _range_position_hi = [row ? _idx : null, _grpIdx, _rowIdx];\n          [_grpIdx, _rowIdx] = [grpIdx, rowIdx];\n        } else {\n          _range_position_hi = [null, null, null];\n        }\n      } else {\n        let i = resultHi - 1;\n        do {\n          _direction = BACKWARDS;\n          [row, _grpIdx, _rowIdx] = previous(\n            groups,\n            groupCount,\n            data,\n            _grpIdx,\n            _rowIdx,\n            navSet,\n            NAV_IDX,\n            NAV_COUNT\n          );\n          if (row) {\n            _idx -= 1;\n            rows.unshift(row);\n            const absRowIdx = _rowIdx === null ? null : row[IDX];\n            _range_positions.unshift(_idx, _grpIdx, _rowIdx, absRowIdx);\n            i -= 1;\n          }\n        } while (row && i >= resultLo);\n        startIdx = _idx;\n        if (row) {\n          const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n          _direction = BACKWARDS;\n          [row, _grpIdx, _rowIdx] = previous(\n            groups,\n            groupCount,\n            data,\n            _grpIdx,\n            _rowIdx,\n            navSet,\n            NAV_IDX,\n            NAV_COUNT\n          );\n          _range_position_lo = [row ? _idx - 1 : 0, _grpIdx, _rowIdx];\n          [_grpIdx, _rowIdx] = [grpIdx, rowIdx];\n        } else {\n          _range_position_lo = [0, null, null];\n        }\n      }\n    } else {\n      // does startIdx remain as null ?\n      // reduced range, adjust the current pos. DIrection can only be a guess, but if it's wrong\n      // the appropriate adjustment will be made nest time range is set\n      if (rangeDiff & RangeFlags.FWD) {\n        console.log(`adjust thye idx`);\n        [_idx, _grpIdx, _rowIdx] = _range_positions.slice(-RANGE_POS_TUPLE_SIZE);\n        _idx += 1;\n      } else {\n        [_idx, _grpIdx, _rowIdx] = _range_positions;\n      }\n    }\n\n    _range = range;\n    result[1] = startIdx;\n    return result;\n    // return [rows, startIdx];\n  }\n\n  function skip(n, fn) {\n    let i = 0;\n    let row;\n\n    do {\n      [row, _grpIdx, _rowIdx] = fn(\n        groups,\n        groupCount,\n        data,\n        _grpIdx,\n        _rowIdx,\n        navSet,\n        NAV_IDX,\n        NAV_COUNT\n      );\n      if (fn === next) {\n        _idx += 1;\n      } else {\n        _idx -= 1;\n      }\n      i += 1;\n    } while (row && i < n);\n    if (fn === next) {\n      _range_position_lo = [_idx - 1, _grpIdx, _rowIdx];\n    } else {\n      _range_position_hi = [_idx, _grpIdx, _rowIdx];\n    }\n  }\n}\n\nfunction getAbsRowIdx(group, relRowIdx, navSet, NAV_IDX) {\n  return navSet[group[NAV_IDX] + relRowIdx];\n}\n\nfunction next(groups, groupCount, rows, grpIdx, rowIdx, navSet, NAV_IDX, NAV_COUNT) {\n  if (grpIdx === null) {\n    grpIdx = -1;\n    do {\n      grpIdx += 1;\n    } while (grpIdx < groups.length && getCount(groups[grpIdx], NAV_COUNT) === 0);\n\n    if (grpIdx >= groups.length) {\n      return NO_RESULT;\n    } else {\n      return [groups[grpIdx], grpIdx, null];\n    }\n  } else if (grpIdx >= groups.length) {\n    return NO_RESULT;\n  } else {\n    let groupRow = groups[grpIdx];\n    const { [IS_EXPANDED]: isExpanded, [DEPTH]: depth, [KEY]: groupKey } = groupRow;\n    const count = getCount(groupRow, NAV_COUNT);\n    // Note: we're unlikely to be passed the row if row count is zero\n    // IF first level of grouping\n    if (\n      depth === groupCount &&\n      isExpanded &&\n      count !== 0 &&\n      (rowIdx === null || rowIdx < count - 1)\n    ) {\n      rowIdx = rowIdx === null ? 0 : rowIdx + 1;\n      const absRowIdx = getAbsRowIdx(groupRow, rowIdx, navSet, NAV_IDX);\n      const row = leafRow(groupKey, rows[absRowIdx]);\n      return [row, grpIdx, rowIdx === null ? 0 : rowIdx];\n    } else if (isExpanded) {\n      do {\n        grpIdx += 1;\n      } while (grpIdx < groups.length && getCount(groups[grpIdx], NAV_COUNT) === 0);\n      if (grpIdx >= groups.length) {\n        return NO_RESULT;\n      } else {\n        return [groups[grpIdx], grpIdx, null];\n      }\n    } else {\n      do {\n        grpIdx += 1;\n      } while (\n        grpIdx < groups.length &&\n        // Need to check that this test i sthe right way round\n        (groups[grpIdx][DEPTH] > depth || getCount(groups[grpIdx], NAV_COUNT) === 0)\n      );\n      if (grpIdx >= groups.length) {\n        return NO_RESULT;\n      } else {\n        return [groups[grpIdx], grpIdx, null];\n      }\n    }\n  }\n}\n\nfunction previous(groups, groupCount, data, grpIdx, rowIdx, navSet, NAV_IDX, NAV_COUNT) {\n  let groupRow = groups[grpIdx];\n  let { [DEPTH]: depth, [KEY]: groupKey, [IS_EXPANDED]: isExpanded } = groupRow;\n\n  if (grpIdx !== null && depth === groupCount && typeof rowIdx === 'number') {\n    if (rowIdx === 0) {\n      return [groupRow, grpIdx, null];\n    } else {\n      rowIdx -= 1;\n      const absRowIdx = getAbsRowIdx(groupRow, rowIdx, navSet, NAV_IDX);\n      const row = leafRow(groupKey, data[absRowIdx]);\n      return [row, grpIdx, rowIdx];\n    }\n  } else {\n    if (grpIdx === null) {\n      grpIdx = groups.length - 1;\n    } else if (grpIdx === 0) {\n      return NO_RESULT;\n    } else {\n      grpIdx -= 1;\n    }\n\n    let groupRow = groups[grpIdx];\n    ({ [DEPTH]: depth, [KEY]: groupKey, [IS_EXPANDED]: isExpanded } = groupRow);\n\n    if (depth === groupCount && isExpanded) {\n      rowIdx = getCount(groupRow, NAV_COUNT) - 1;\n      const absRowIdx = getAbsRowIdx(groupRow, rowIdx, navSet, NAV_IDX);\n      const row = leafRow(groupKey, data[absRowIdx]);\n      return [row, grpIdx, rowIdx];\n    }\n    while (groupRow[PARENT_IDX] !== null && groups[groupRow[PARENT_IDX]][IS_EXPANDED] === false) {\n      grpIdx = groupRow[metadataKeys.PARENT_IDX];\n      groupRow = groups[grpIdx];\n    }\n    return [groupRow, grpIdx, null];\n  }\n}\n", "import {\n  ASC,\n  mapSortCriteria,\n  extendsFilter,\n  functor as filterPredicate,\n  metadataKeys\n} from '@vuu-ui/utils';\nimport BaseRowSet from './rowSet';\nimport {\n  expandRow,\n  findSortedCol,\n  findDoomedColumnDepths,\n  findGroupPositions,\n  getGroupStateChanges,\n  groupbyExtendsExistingGroupby,\n  groupbyReducesExistingGroupby,\n  groupbySortReversed,\n  groupRows,\n  splitGroupsAroundDoomedGroup,\n  lowestIdxPointer,\n  GroupIdxTracker,\n  SimpleTracker,\n  getCount,\n  aggregateGroup,\n  findAggregatedColumns,\n  adjustGroupIndices,\n  adjustLeafIdxPointers,\n  allGroupsExpanded\n} from '../group-utils';\nimport { sortBy, sortPosition } from '../sort';\nimport GroupIterator from '../group-iterator';\nimport { NULL_RANGE } from '../range-utils';\nimport { leafRow } from '../group-utils';\n\nconst EMPTY_ARRAY = [];\n\nexport class GroupRowSet extends BaseRowSet {\n  constructor(\n    rowSet,\n    columns,\n    groupby,\n    groupState,\n    sortCriteria = null,\n    filter = rowSet.currentFilter\n  ) {\n    super(rowSet.table, rowSet.baseOffset, rowSet.range);\n    this.columns = columns;\n    this.groupby = groupby;\n    this.groupState = groupState;\n    this.aggregations = [];\n    this.currentLength = 0; // TODO\n    this.groupRows = [];\n    this.aggregatedColumn = {};\n\n    this.collapseChildGroups = this.collapseChildGroups.bind(this);\n    this.countChildGroups = this.countChildGroups.bind(this);\n\n    columns.forEach((column) => {\n      if (column.aggregate) {\n        const key = rowSet.table.columnMap[column.name];\n        this.aggregations.push([key, column.aggregate]); // why ?\n        this.aggregatedColumn[key] = column.aggregate;\n      }\n    });\n    this.expandedByDefault = false;\n    this.sortCriteria = Array.isArray(sortCriteria) && sortCriteria.length ? sortCriteria : null;\n\n    // can we lazily build the sortSet as we fetch data for the first time ?\n    this.sortSet = rowSet.data.map((d, i) => i);\n    // we will store an array of pointers to parent Groups.mirroring sequence of leaf rows\n    this.rowParents = Array(rowSet.data.length);\n\n    this.applyGroupby(groupby);\n\n    const [navSet, IDX, COUNT] = this.selectNavigationSet(false);\n    // TODO roll the IDX and COUNT overrides into meta\n    this.iter = GroupIterator(this.groupRows, this.groupBy, navSet, this.data, IDX, COUNT);\n\n    if (filter) {\n      this.filter(filter);\n    }\n  }\n\n  get length() {\n    return this.currentLength;\n  }\n  get first() {\n    return this.data[0];\n  }\n  get last() {\n    return this.data[this.data.length - 1];\n  }\n\n  currentRange() {\n    return this.setRange(this.range, false);\n  }\n\n  clearRange() {\n    this.iter.clear();\n    this.range = NULL_RANGE;\n  }\n\n  setSubscribedColumns(columns) {\n    console.log(`GroupRowset setSubscribedColumns ${columns.join(',')}`);\n  }\n\n  setRange(range, useDelta = true) {\n    // A common scenario, eg after groupBy or sort, reposition range at top of viewport\n    if (useDelta === false && range.lo === 0) {\n      this.clearRange();\n    }\n\n    const [rowsInRange, idx] =\n      !useDelta && range.lo === this.range.lo && range.hi === this.range.hi\n        ? this.iter.currentRange()\n        : this.iter.setRange(range, useDelta);\n\n    const filterCount = this.filterSet && metadataKeys.FILTER_COUNT;\n    const rows = rowsInRange.map((row, i) => this.cloneRow(row, idx + i, filterCount));\n    this.range = range;\n    return {\n      dataType: this.type,\n      rows,\n      range,\n      size: this.currentLength,\n      offset: this.offset,\n      stats: undefined\n    };\n  }\n\n  cloneRow(row, idx, FILTER_COUNT) {\n    const { IDX, DEPTH, COUNT } = metadataKeys;\n    const dolly = row.slice();\n    dolly[IDX] = idx + this.offset;\n\n    if (FILTER_COUNT && dolly[DEPTH] !== 0 && typeof dolly[FILTER_COUNT] === 'number') {\n      dolly[COUNT] = dolly[FILTER_COUNT];\n    }\n    return dolly;\n  }\n\n  applyGroupby(groupby, rows = this.data) {\n    const { columns } = this;\n    this.groupRows.length = 0;\n    const groupCols = mapSortCriteria(groupby, this.table.columnMap);\n    this.groupRows = groupRows(rows, this.sortSet, columns, this.table.columnMap, groupCols, {\n      groups: this.groupRows,\n      rowParents: this.rowParents\n    });\n    this.currentLength = this.countVisibleRows(this.groupRows, this.groupBy);\n  }\n\n  groupBy(groupby) {\n    if (groupbySortReversed(groupby, this.groupby)) {\n      this.sortGroupby(groupby);\n    } else if (groupbyExtendsExistingGroupby(groupby, this.groupby)) {\n      this.extendGroupby(groupby);\n      this.currentLength = this.countVisibleRows(\n        this.groupRows,\n        this.groupBy,\n        this.filterSet !== null\n      );\n    } else if (groupbyReducesExistingGroupby(groupby, this.groupby)) {\n      this.reduceGroupby(groupby);\n      this.range = NULL_RANGE;\n      this.iter.clear();\n      this.currentLength = this.countVisibleRows(\n        this.groupRows,\n        this.groupBy,\n        this.filterSet !== null\n      );\n    } else {\n      this.applyGroupby(groupby);\n    }\n\n    this.iter.setGroupCount(groupby.length);\n    this.groupby = groupby;\n  }\n\n  // User interaction will never produce more than one change, but programatic change might !\n  //TODO if we have sortCriteria, apply to leaf rows as we expand\n  setGroupState(groupState) {\n    // onsole.log(`[groupRowSet.setGroupState] ${JSON.stringify(groupState,null,2)}`)\n    const changes = getGroupStateChanges(groupState, this.groupState);\n    changes.forEach(([key, , isExpanded]) => {\n      const { groupRows } = this;\n      if (key === '*') {\n        this.toggleAll(isExpanded);\n        this.currentLength = this.countVisibleRows(groupRows, this.groupBy, false);\n      } else {\n        const groupIdx = this.findGroupIdx(key);\n        if (groupIdx !== -1) {\n          if (isExpanded) {\n            this.currentLength += this.expandGroup(groupIdx, groupRows);\n          } else {\n            this.currentLength -= this.collapseGroup(groupIdx, groupRows);\n          }\n        } else {\n          console.warn(`setGroupState could not find row to toggle`);\n        }\n      }\n    });\n    this.groupState = groupState;\n  }\n\n  expandGroup(idx, groups) {\n    return this.toggleGroup(idx, groups, this.countChildGroups);\n  }\n\n  collapseGroup(idx, groups) {\n    return this.toggleGroup(idx, groups, this.collapseChildGroups);\n  }\n\n  toggleGroup(groupIdx, groupRows, processChildGroups) {\n    const { COUNT, DEPTH, FILTER_COUNT, IS_EXPANDED } = metadataKeys;\n    let adjustment = 0;\n    const groupRow = groupRows[groupIdx];\n    const depth = groupRow[DEPTH];\n    const isExpanded = groupRow[IS_EXPANDED];\n    const maxDepth = this.groupby.length;\n\n    const useFilter = this.filterSet !== null;\n    groupRow[IS_EXPANDED] = !isExpanded;\n    if (depth === maxDepth) {\n      const COUNT_IDX = useFilter ? FILTER_COUNT : COUNT;\n      adjustment = groupRow[COUNT_IDX];\n    } else {\n      adjustment = processChildGroups(depth + 1, groupIdx + 1, groupRows, useFilter);\n    }\n    return adjustment;\n  }\n\n  countChildGroups(childDepth, startIdx, groupRows, useFilter) {\n    const { DEPTH, FILTER_COUNT } = metadataKeys;\n    let adjustment = 0;\n    for (let i = startIdx; i < groupRows.length; i++) {\n      const nextDepth = groupRows[i][DEPTH];\n      if (nextDepth === childDepth) {\n        if (!useFilter || groupRows[i][FILTER_COUNT] > 0) {\n          adjustment += 1;\n        }\n      } else if (nextDepth < childDepth) {\n        break;\n      }\n    }\n    return adjustment;\n  }\n\n  collapseChildGroups(childDepth, startIdx, groupRows, useFilter) {\n    const { DEPTH, FILTER_COUNT, IS_EXPANDED } = metadataKeys;\n    let adjustment = 0;\n    for (let i = startIdx; i < groupRows.length; i++) {\n      const { [DEPTH]: nextDepth, [IS_EXPANDED]: isNextExpanded } = groupRows[i];\n      if (nextDepth === childDepth) {\n        if (!useFilter || groupRows[i][FILTER_COUNT] > 0) {\n          adjustment += 1;\n          if (isNextExpanded) {\n            adjustment += this.collapseGroup(i, groupRows);\n          }\n        }\n      } else if (nextDepth < childDepth) {\n        break;\n      }\n    }\n    return adjustment;\n  }\n\n  sort(sortCriteria) {\n    const { groupRows: groups } = this;\n    const { IDX, DEPTH, COUNT, IDX_POINTER } = metadataKeys;\n    this.sortCriteria = Array.isArray(sortCriteria) && sortCriteria.length ? sortCriteria : null;\n\n    const sortCols = mapSortCriteria(sortCriteria, this.table.columnMap);\n    //TODO only need to handle visible rows\n    for (let i = 0; i < groups.length; i++) {\n      const groupRow = groups[i];\n      const depth = groupRow[DEPTH];\n      const count = groupRow[COUNT];\n      const absDepth = Math.abs(depth);\n      const sortIdx = groupRow[IDX_POINTER];\n      if (absDepth === 1) {\n        this.sortDataSubset(sortIdx, count, sortCols, IDX);\n      }\n    }\n  }\n\n  sortDataSubset(startIdx, length, sortCriteria, IDX) {\n    const rows = [];\n    for (let i = startIdx; i < startIdx + length; i++) {\n      const rowIdx = this.sortSet[i];\n      rows.push(this.data[rowIdx]);\n    }\n    rows.sort(sortBy(sortCriteria));\n    for (let i = 0; i < rows.length; i++) {\n      this.sortSet[i + startIdx] = rows[i][IDX];\n    }\n  }\n\n  clearFilter(/*cloneChanges*/) {\n    this.currentFilter = null;\n    this.filterSet = null;\n    // rebuild agregations for groups where filter count is less than count, remove filter count\n    const { data: rows, groupRows, sortSet, columns } = this;\n    const { COUNT, FILTER_COUNT, NEXT_FILTER_IDX } = metadataKeys;\n    const maxDepth = this.groupby.length;\n    const aggregations = findAggregatedColumns(columns, this.table.columnMap, this.groupby);\n\n    for (let i = 0; i < groupRows.length; i++) {\n      let groupRow = groupRows[i];\n      if (typeof groupRow[FILTER_COUNT] === 'number' && groupRow[COUNT] > groupRow[FILTER_COUNT]) {\n        aggregateGroup(groupRows, i, sortSet, rows, columns, aggregations, maxDepth);\n        groupRow[FILTER_COUNT] = null;\n        groupRow[NEXT_FILTER_IDX] = null;\n      }\n    }\n\n    this.iter.setNavSet(this.selectNavigationSet(false));\n    this.currentLength = this.countVisibleRows(groupRows, false);\n  }\n\n  filter(filter) {\n    const extendsCurrentFilter = extendsFilter(this.currentFilter, filter);\n    const fn = filter && filterPredicate(this.table.columnMap, filter);\n    const { COUNT, DEPTH, PARENT_IDX, FILTER_COUNT, NEXT_FILTER_IDX } = metadataKeys;\n    const { data: rows, groupRows: groups } = this;\n    let [navSet, NAV_IDX, NAV_COUNT] = this.selectNavigationSet(\n      extendsCurrentFilter && this.filterSet\n    );\n    const newFilterSet = [];\n\n    for (let i = 0; i < groups.length; i++) {\n      let groupRow = groups[i];\n      const depth = groupRow[DEPTH];\n      const count = getCount(groupRow, NAV_COUNT, COUNT);\n      const absDepth = Math.abs(depth);\n\n      if (absDepth === 1) {\n        const sortIdx = groupRow[NAV_IDX];\n        let rowCount = 0;\n\n        for (let ii = sortIdx; ii < sortIdx + count; ii++) {\n          const rowIdx = navSet[ii];\n          const row = rows[rowIdx];\n          const includerow = fn(row);\n          if (includerow) {\n            rowCount += 1;\n            if (rowCount === 1) {\n              groupRow[NEXT_FILTER_IDX] = newFilterSet.length;\n            }\n            newFilterSet.push(rowIdx);\n          }\n        }\n\n        groupRow[FILTER_COUNT] = rowCount;\n        let aggregations = EMPTY_ARRAY;\n        // we cannot be sure what filter changes have taken effect, so we must recalculate aggregations\n        if (this.aggregations.length) {\n          aggregations = this.aggregations.map(([i, a]) => [i, a, 0]);\n          const len = newFilterSet.length;\n          for (let ii = len - rowCount; ii < len; ii++) {\n            const rowIdx = newFilterSet[ii];\n            const row = rows[rowIdx];\n            for (let j = 0; j < aggregations.length; j++) {\n              let [colIdx] = aggregations[j];\n              aggregations[j][2] += row[colIdx];\n            }\n          }\n\n          // 2) store aggregates at lowest level of the group hierarchy\n          aggregations.forEach((aggregation) => {\n            const [colIdx, type, sum] = aggregation;\n            const dataIdx = colIdx + metadataKeys.count - 2; // <<<<<<<<<<<\n            if (type === 'sum') {\n              groupRow[dataIdx] = sum;\n            } else if (type === 'avg') {\n              groupRow[dataIdx] = sum / rowCount;\n            }\n          });\n        }\n\n        // update parent counts\n        if (rowCount > 0) {\n          let parentGroupRow = groupRow;\n          while (parentGroupRow[PARENT_IDX] !== null) {\n            groupRow = groups[parentGroupRow[PARENT_IDX]];\n\n            aggregations.forEach((aggregation) => {\n              const [colIdx, type, sum] = aggregation;\n              const dataIdx = colIdx + metadataKeys.count - 2; // <<<<<<<<<<<\n              if (type === 'sum') {\n                parentGroupRow[dataIdx] += sum;\n              } else if (type === 'avg') {\n                const originalCount = parentGroupRow[FILTER_COUNT];\n                const originalSum = originalCount * parentGroupRow[dataIdx];\n                parentGroupRow[dataIdx] = (originalSum + sum) / (originalCount + rowCount);\n              }\n            });\n            parentGroupRow[FILTER_COUNT] += rowCount;\n          }\n        }\n      } else {\n        // Higher-level group aggregations are calculated from lower level groups\n        // initialize aggregated columns\n        groupRow[FILTER_COUNT] = 0;\n        this.aggregations.forEach((aggregation) => {\n          const [colIdx] = aggregation;\n          const dataIdx = colIdx + metadataKeys.count - 2; // <<<<<<<<<<<\n          groupRow[dataIdx] = 0;\n        });\n      }\n    }\n    this.filterSet = newFilterSet;\n    this.currentFilter = filter;\n    this.currentLength = this.countVisibleRows(this.groupRows, true);\n\n    this.iter.setNavSet(this.selectNavigationSet(true));\n  }\n\n  update(rowIdx, updates) {\n    const {\n      groupRows: groups,\n      offset,\n      rowParents,\n      range: { lo }\n    } = this;\n    const { COUNT, FILTER_COUNT, PARENT_IDX } = metadataKeys;\n\n    let groupUpdates;\n    const rowUpdates = [];\n\n    for (let i = 0; i < updates.length; i += 3) {\n      // the col mappings in updates refer to base column definitions\n      const colIdx = updates[i];\n      const dataIdx = colIdx + metadataKeys.count - 2; // <<<<<<<<<<<\n\n      const originalValue = updates[i + 1];\n      const value = updates[i + 2];\n      rowUpdates.push(dataIdx, originalValue, value);\n\n      let grpIdx = rowParents[rowIdx];\n      // this seems to return 0 an awful lot\n      let ii = 0;\n\n      // If this column is being aggregated\n      if (this.aggregatedColumn[colIdx]) {\n        groupUpdates = groupUpdates || [];\n        // collect adjusted aggregations for each group level\n        do {\n          let groupRow = groups[grpIdx];\n          let originalGroupValue = groupRow[dataIdx];\n          const diff = value - originalValue;\n          const type = this.aggregatedColumn[colIdx];\n          if (type === 'sum') {\n            // ... wnd in the groupRow we have a further offset of 2 ...\n            groupRow[dataIdx] += diff; // again with the +2\n          } else if (type === 'avg') {\n            const count = getCount(groupRow, FILTER_COUNT, COUNT);\n            groupRow[dataIdx] = (groupRow[dataIdx] * count + diff) / count;\n          }\n\n          (groupUpdates[ii] || (groupUpdates[ii] = [grpIdx])).push(\n            dataIdx,\n            originalGroupValue,\n            groupRow[dataIdx]\n          );\n\n          grpIdx = groupRow[PARENT_IDX];\n          ii += 1;\n        } while (grpIdx !== null);\n      }\n    }\n\n    const outgoingUpdates = [];\n    // check rangeIdx for both row and group updates, if they are not in range, they have not been\n    // sent to client and do not need to be added to outgoing updates\n    if (groupUpdates) {\n      // the groups are currently in reverse order, lets send them out outermost group first\n      for (let i = groupUpdates.length - 1; i >= 0; i--) {\n        const [grpIdx, ...updates] = groupUpdates[i];\n        // won't work - need to chnage groupIterator\n        const rangeIdx = this.iter.getRangeIndexOfGroup(grpIdx);\n        if (rangeIdx !== -1) {\n          outgoingUpdates.push([lo + rangeIdx + offset, ...updates]);\n        }\n      }\n    }\n    const rangeIdx = this.iter.getRangeIndexOfRow(rowIdx);\n    if (rangeIdx !== -1) {\n      // onsole.log(`[GroupRowSet.update] updates for row idx ${idx} ${rangeIdx+offset} ${JSON.stringify(rowUpdates)}`)\n      outgoingUpdates.push([lo + rangeIdx + offset, ...rowUpdates]);\n    }\n\n    return outgoingUpdates;\n  }\n\n  insert(newRowIdx, row) {\n    // TODO look at append and idx manipulation for insertion at head.\n    const { groupRows: groups, groupby, data: rows, sortSet, columns, iter: iterator } = this;\n\n    let dataGroupCols = mapSortCriteria(groupby, this.table.columnMap, metadataKeys.count - 2); // <<<<<<<<<\n    const groupPositions = findGroupPositions(groups, dataGroupCols, leafRow(row));\n\n    const { IDX, COUNT, KEY, IDX_POINTER } = metadataKeys;\n    const GROUP_KEY_SORT = [[KEY, 'asc']];\n    const allGroupsExist = groupPositions.length === groupby.length;\n    const noGroupsExist = groupPositions.length === 0;\n    const someGroupsExist = !noGroupsExist && !allGroupsExist;\n    let result;\n    let newGroupIdx = null;\n\n    if (allGroupsExist) {\n      // all necessary groups are already in place, we will just insert a row and update counts/aggregates\n      let grpIdx = groupPositions[groupPositions.length - 1];\n      const groupRow = groups[grpIdx];\n      this.rowParents[newRowIdx] = grpIdx;\n      let count = groupRow[COUNT];\n\n      const insertionPoint = groupRow[IDX_POINTER] + count;\n      // all existing pointers from the insertionPoint forward are going to be displaced by +1\n      adjustLeafIdxPointers(groups, insertionPoint);\n      sortSet.splice(insertionPoint, 0, row[IDX]);\n      if (allGroupsExpanded(groups, groupRow)) {\n        this.currentLength += 1;\n      }\n    } else {\n      let groupCols = mapSortCriteria(groupby, this.table.columnMap);\n      newGroupIdx = sortPosition(\n        groups,\n        sortBy(GROUP_KEY_SORT),\n        expandRow(groupCols, row, metadataKeys),\n        'last-available'\n      );\n      sortSet.push(newRowIdx);\n      let nestedGroups, baseGroupby, rootIdx;\n\n      if (someGroupsExist) {\n        baseGroupby = groupCols.slice(0, groupPositions.length);\n        rootIdx = groups[groupPositions[groupPositions.length - 1]][IDX];\n        groupCols = groupCols.slice(groupPositions.length);\n      }\n\n      nestedGroups = groupRows(rows, sortSet, columns, this.table.columnMap, groupCols, {\n        startIdx: sortSet.length - 1,\n        length: 1,\n        groupIdx: newGroupIdx - 1,\n        baseGroupby,\n        rootIdx\n      });\n\n      adjustGroupIndices(groups, newGroupIdx, nestedGroups.length);\n      groups.splice.apply(groups, [newGroupIdx, 0].concat(nestedGroups));\n    }\n\n    // Note: we update the aggregates\n    this.updateAggregatedValues(groupPositions, row);\n    this.incrementGroupCounts(groupPositions);\n\n    iterator.refresh(); // force iterator to rebuild rangePositions\n    let rangeIdx = allGroupsExist\n      ? iterator.getRangeIndexOfRow(newRowIdx)\n      : iterator.getRangeIndexOfGroup(newGroupIdx);\n\n    if (rangeIdx !== -1) {\n      // New row is visible within viewport so we will force render all rows\n      result = { replace: true };\n      if (newGroupIdx !== null) {\n        this.currentLength += 1;\n      }\n    } else if (noGroupsExist === false) {\n      // new row is not visible as group is collapsed, but we need to update groiup row(s)\n      result = { updates: this.collectGroupUpdates(groupPositions) };\n    }\n\n    return result;\n  }\n\n  incrementGroupCounts(groupPositions) {\n    const { groupRows } = this;\n    const { COUNT } = metadataKeys;\n    groupPositions.forEach((grpIdx) => {\n      const group = groupRows[grpIdx];\n      group[COUNT] += 1;\n    });\n  }\n\n  updateAggregatedValues(groupPositions, row) {\n    const { groupRows } = this;\n\n    groupPositions.forEach((grpIdx) => {\n      const groupRow = groupRows[grpIdx];\n      for (let [colIdx, type] of this.aggregations) {\n        const value = row[colIdx];\n        const dataIdx = colIdx + metadataKeys.count - 2; // <<<<<<<<<<<\n        const groupValue = groupRow[dataIdx];\n        if (type === 'sum') {\n          groupRow[dataIdx] = groupValue + value;\n        } else if (type === 'avg') {\n          const originalCount = groupRow[metadataKeys.COUNT]; // do we need to consider the FILTER_COUNT ?\n          const originalSum = originalCount * groupRow[dataIdx];\n          groupRow[dataIdx] = (originalSum + value) / (originalCount + 1);\n        }\n      }\n    });\n  }\n\n  collectGroupUpdates(groupPositions) {\n    const { aggregations, groupRows: groups, offset } = this;\n    const { COUNT } = metadataKeys;\n    const updates = [];\n    for (let grpIdx of groupPositions) {\n      const rangeIdx = this.iter.getRangeIndexOfGroup(grpIdx);\n      if (rangeIdx !== -1) {\n        const group = groups[grpIdx];\n        const update = [rangeIdx + offset, COUNT, group[COUNT]];\n        for (let [colIdx] of aggregations) {\n          const dataIdx = colIdx + metadataKeys.count - 2; // <<<<<<<<<<<\n          update.push(dataIdx, group[dataIdx]);\n        }\n        updates.push(update);\n      }\n    }\n    return updates;\n  }\n\n  // start with a simplesequential search\n  findGroupIdx(groupKey) {\n    const { groupRows } = this;\n    for (let i = 0; i < groupRows.length; i++) {\n      if (groupRows[i][metadataKeys.KEY] === groupKey) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  //TODO simple implementation first\n  toggleAll(isExpanded) {\n    const sign = isExpanded ? 1 : -1;\n    // iterate groupedRows and make every group row depth positive,\n    // Then visible rows is not going to be different from grouped rows\n    const { DEPTH } = metadataKeys;\n    const { groupRows: groups } = this;\n    this.expandedByDefault = isExpanded;\n    for (let i = 0, len = groups.length; i < len; i++) {\n      const depth = groups[i][DEPTH];\n      // if (depth !== 0) {\n      groups[i][DEPTH] = Math.abs(depth) * sign;\n      // }\n    }\n  }\n\n  sortGroupby(groupby) {\n    const { IDX, KEY, DEPTH, IDX_POINTER, PARENT_IDX } = metadataKeys;\n    const { groupRows } = this;\n    const groupCols = mapSortCriteria(groupby, this.table.columnMap, metadataKeys.count - 2);\n    const [colIdx, depth] = findSortedCol(groupby, this.groupby);\n    let count = 0;\n    let i = 0;\n    for (; i < groupRows.length; i++) {\n      if (Math.abs(groupRows[i][DEPTH]) > depth) {\n        if (count > 0) {\n          this.sortGroupRowsSubset(groupCols, colIdx, i - count, count);\n          count = 0;\n        }\n      } else {\n        count += 1;\n      }\n    }\n\n    this.sortGroupRowsSubset(groupCols, colIdx, i - count, count);\n\n    const tracker = new SimpleTracker(groupby.length);\n    this.groupRows.forEach((groupRow, i) => {\n      const depth = groupRow[DEPTH];\n      const groupKey = groupRow[KEY];\n      const absDepth = Math.abs(depth);\n      tracker.set(absDepth, i, groupKey);\n      groupRow[IDX] = i;\n      if (absDepth > 1) {\n        groupRow[IDX_POINTER] = i + 1;\n      }\n      if (tracker.hasParentPos(absDepth)) {\n        groupRow[PARENT_IDX] = tracker.parentPos(absDepth);\n      }\n    });\n  }\n\n  sortGroupRowsSubset(groupby, colIdx, startPos = 0, length = this.groupRows.length) {\n    const { groupRows } = this;\n    let insertPos = startPos + length;\n    const [groupColIdx, direction] = groupby[colIdx];\n    const before = (k1, k2) => (direction === ASC ? k2 > k1 : k1 > k2);\n    const after = (k1, k2) => (direction === ASC ? k2 < k1 : k1 < k2);\n    let currentKey = null;\n    for (let i = startPos; i < startPos + length; i++) {\n      const key = groupRows[i][groupColIdx];\n      if (currentKey === null) {\n        currentKey = key;\n      } else if (before(key, currentKey)) {\n        const splicedRows = groupRows.splice(startPos, i - startPos);\n        insertPos -= splicedRows.length;\n        groupRows.splice.apply(groupRows, [insertPos, 0].concat(splicedRows));\n        currentKey = key;\n        i = startPos - 1;\n      } else if (after(key, currentKey)) {\n        break;\n      }\n    }\n  }\n\n  // there is a current assumption here that new col(s) are always added at the end of existing cols in the groupBy\n  // Need to think about a new col inserted at start or in between existing cols\n  //TODO we might want to do this on expanded nodes only and repat in a lazy fashion as more nodes are revealed\n  extendGroupby(groupby) {\n    const groupCols = mapSortCriteria(groupby, this.table.columnMap);\n    const baseGroupCols = groupCols.slice(0, this.groupby.length);\n    const newGroupbyClause = groupCols.slice(this.groupby.length);\n    const {\n      groupRows: groups,\n      groupby: baseGroupby,\n      data: rows,\n      columns,\n      sortSet,\n      filterSet\n    } = this;\n    const { IDX_POINTER, PARENT_IDX, NEXT_FILTER_IDX } = metadataKeys;\n    const baseLevels = baseGroupby.length;\n    const tracker = new GroupIdxTracker(baseLevels - 1);\n    const filterFn = this.currentFilter\n      ? filterPredicate(this.table.columnMap, this.currentFilter)\n      : null;\n\n    // we are going to insert new rows into groupRows and update the PARENT_IDX pointers in data rows\n    for (let i = 0; i < groups.length; i++) {\n      const groupRow = groups[i];\n      if (tracker.idxAdjustment) {\n        groupRow[metadataKeys.IDX] += tracker.idxAdjustment;\n      }\n\n      const rootIdx = groupRow[metadataKeys.IDX];\n      const depth = groupRow[metadataKeys.DEPTH];\n      const length = groupRow[metadataKeys.COUNT];\n      const groupKey = groupRow[metadataKeys.KEY];\n\n      const filterLength = groupRow[metadataKeys.FILTER_COUNT];\n      const filterIdx = groupRow[NEXT_FILTER_IDX];\n      groupRow[metadataKeys.NEXT_FILTER_IDX] = undefined;\n\n      if (tracker.hasPrevious(depth + 1)) {\n        groupRow[PARENT_IDX] += tracker.previous(depth + 1);\n      }\n\n      if (depth === baseLevels) {\n        const startIdx = groupRow[IDX_POINTER];\n        const nestedGroupRows = groupRows(\n          rows,\n          sortSet,\n          columns,\n          this.table.columnMap,\n          newGroupbyClause,\n          {\n            depth: depth + 1,\n            startIdx,\n            length,\n            rootIdx,\n            baseGroupby: baseGroupCols,\n            groupIdx: rootIdx,\n            filterIdx,\n            filterLength,\n            filterSet,\n            filterFn,\n            rowParents: this.rowParents\n          }\n        );\n        const nestedGroupCount = nestedGroupRows.length;\n        // this might be a performance problem for large arrays, might need to concat\n        groups.splice(i + 1, 0, ...nestedGroupRows);\n        i += nestedGroupCount;\n        tracker.increment(nestedGroupCount);\n      } else {\n        tracker.set(depth, groupKey);\n      }\n      // This has to be a pointer into sortSet NOT rows\n      groupRow[IDX_POINTER] = rootIdx + 1;\n    }\n  }\n\n  reduceGroupby(groupby) {\n    const { groupRows: groups, filterSet } = this;\n    const [doomed] = findDoomedColumnDepths(groupby, this.groupby);\n    const groupCols = mapSortCriteria(this.groupby, this.table.columnMap);\n    const [lastGroupIsDoomed, baseGroupby, addGroupby] = splitGroupsAroundDoomedGroup(\n      groupCols,\n      doomed\n    );\n    const { IDX, DEPTH, KEY, IDX_POINTER, PARENT_IDX, NEXT_FILTER_IDX } = metadataKeys;\n    const maxDepth = groupby.length;\n    const tracker = new GroupIdxTracker(maxDepth);\n    const useFilter = filterSet !== null;\n    let currentGroupIdx = null;\n    let i = 0;\n    for (let len = groups.length; i < len; i++) {\n      const groupRow = groups[i];\n      const depth = groupRow[DEPTH];\n      const groupKey = groupRow[KEY];\n\n      if (depth === doomed) {\n        this.reParentLeafRows(i, currentGroupIdx);\n        groups.splice(i, 1);\n        i -= 1;\n        len -= 1;\n        tracker.increment(1);\n      } else {\n        if (depth < doomed) {\n          tracker.set(depth, groupKey);\n          if (depth === doomed - 1) {\n            if (lastGroupIsDoomed) {\n              // our pointer will no longer be to a child group but (via the sortSet) to the data.\n              // This can be taken from the first child group (which will be removed)\n              groupRow[IDX_POINTER] = lowestIdxPointer(\n                groups,\n                IDX_POINTER,\n                DEPTH,\n                i + 1,\n                depth + 1\n              );\n              groupRow[NEXT_FILTER_IDX] = useFilter\n                ? lowestIdxPointer(groups, NEXT_FILTER_IDX, DEPTH, i + 1, depth + 1)\n                : undefined;\n            } else if (currentGroupIdx !== null) {\n              const diff = this.regroupChildGroups(currentGroupIdx, i, baseGroupby, addGroupby);\n              i -= diff;\n              len -= diff;\n              tracker.increment(diff);\n            }\n          }\n          currentGroupIdx = i;\n          if (tracker.hasPrevious(depth - 1)) {\n            groupRow[PARENT_IDX] -= tracker.previous(depth - 1);\n          }\n        }\n        if (tracker.idxAdjustment > 0) {\n          groupRow[IDX] -= tracker.idxAdjustment;\n          if (groupRow[DEPTH] < maxDepth) {\n            groupRow[IDX_POINTER] -= tracker.idxAdjustment;\n          }\n        }\n      }\n    }\n    if (!lastGroupIsDoomed) {\n      // don't forget the final group ...\n      this.regroupChildGroups(currentGroupIdx, i, baseGroupby, addGroupby);\n    }\n  }\n\n  reParentLeafRows(groupIdx, newParentGroupIdx) {\n    // TODO what about filterSet ?\n    const { groupRows: groups, rowParents, sortSet } = this;\n    const { IDX_POINTER, COUNT } = metadataKeys;\n    const group = groups[groupIdx];\n    const idx = group[IDX_POINTER];\n    const count = group[COUNT];\n\n    for (let i = idx; i < idx + count; i++) {\n      const rowIdx = sortSet[i];\n      rowParents[rowIdx] = newParentGroupIdx;\n    }\n  }\n\n  regroupChildGroups(currentGroupIdx, nextGroupIdx, baseGroupby, addGroupby) {\n    const { groupRows: groups, data: rows, columns } = this;\n    const { COUNT, IDX_POINTER } = metadataKeys;\n    const group = groups[currentGroupIdx];\n    const length = group[COUNT];\n    const startIdx = groups[currentGroupIdx + 1][IDX_POINTER];\n    // We don't really need to go back to rows to regroup, we have partially grouped data already\n    // we could perform the whole operation within groupRows\n    const nestedGroupRows = groupRows(\n      rows,\n      this.sortSet,\n      columns,\n      this.table.columnMap,\n      addGroupby,\n      {\n        startIdx,\n        length,\n        rootIdx: currentGroupIdx,\n        baseGroupby,\n        groupIdx: currentGroupIdx,\n        rowParents: this.rowParents\n      }\n    );\n    const existingChildNodeCount = nextGroupIdx - currentGroupIdx - 1;\n    groups.splice(currentGroupIdx + 1, existingChildNodeCount, ...nestedGroupRows);\n    group[IDX_POINTER] = currentGroupIdx + 1;\n    return existingChildNodeCount - nestedGroupRows.length;\n  }\n\n  // Note: this assumes no leaf rows visible. Is that always valid ?\n  // NOt after removing a groupBy ! Not after a filter\n  countVisibleRows(groupRows, groupCount, usingFilter = false) {\n    const { IS_EXPANDED, DEPTH, COUNT, FILTER_COUNT } = metadataKeys;\n    let count = 0;\n    for (let i = 0, len = groupRows.length; i < len; i++) {\n      const zeroCount = usingFilter && groupRows[i][FILTER_COUNT] === 0;\n      if (!zeroCount) {\n        count += 1;\n      }\n      const { [IS_EXPANDED]: isExpanded, [DEPTH]: depth } = groupRows[i];\n      if (!isExpanded || zeroCount) {\n        while (i < len - 1 && Math.abs(groupRows[i + 1][DEPTH]) > depth) {\n          i += 1;\n        }\n      } else if (depth === groupCount) {\n        count += usingFilter ? groupRows[i][FILTER_COUNT] : groupRows[i][COUNT];\n      }\n    }\n    return count;\n  }\n}\n", "/*\n    Inserts (and size records) and updates must be batched separately. Because updates are \n    keyed by index position and index positions may be affected by an insert operation, the\n    timeline must be preserved. Updates can be coalesced until an insert is received. Then\n    the update batch must be closed, to be followed by the insert(s). Similarly, multiple\n    inserts, with no interleaved updates, can be batched (with a single size record). The batch\n    will be closed as soon as the next update is received. So we alternate between update and\n    insert processing, with each transition athe preceeding batch is closed off.\n    An append is a simple insert that has no re-indexing implications.  \n\n*/\nexport default class UpdateQueue {\n  constructor() {\n    this._queue = [];\n  }\n\n  get length() {\n    return this._queue.length;\n  }\n\n  update(update) {\n    //TODO we could also coalesce updates into an insert or rowset, if present\n    const batch = this.getCurrentBatch('update');\n\n    const [rowIdx] = update;\n    const { updates } = batch;\n\n    for (let i = 0, len = updates.length; i < len; i++) {\n      if (updates[i][0] === rowIdx) {\n        // we already have an update for this item, update the update...\n        let d = updates[i];\n        for (let colIdx = 1; colIdx < update.length; colIdx += 2) {\n          const pos = d.indexOf(update[colIdx]);\n          if (pos === -1) {\n            // should check that it is really a colIdx,not a value\n            d.push(update[colIdx], update[colIdx + 1]);\n          } else {\n            d[pos + 1] = update[colIdx + 1];\n          }\n        }\n\n        return;\n      }\n    }\n    updates.push(update);\n  }\n\n  resize(size) {\n    const batch = this.getCurrentBatch('size');\n    batch.size = size;\n  }\n\n  append(row, offset) {\n    const batch = this.getCurrentBatch('insert');\n    //onsole.log(`UpdateQueue append ${row[0]}`);\n    batch.rows.push(row);\n    batch.offset = offset;\n  }\n\n  replace({ rows, filter, size, range, offset }) {\n    const batch = this.getCurrentBatch('rowset');\n    batch.rows = rows;\n    batch.size = size;\n    batch.range = range;\n    batch.offset = offset;\n    // HM, think we should fire an immediate response for filter change\n    batch.filter = filter;\n  }\n\n  popAll() {\n    const results = this._queue;\n    this._queue = [];\n    return results;\n  }\n\n  getCurrentBatch(type) {\n    const q = this._queue;\n    const len = q.length;\n\n    let batch = len === 0 || type === 'rowset' ? (q[0] = createBatch(type)) : q[len - 1];\n\n    if (batch.type !== type) {\n      // roll size recored into subsequent insert\n      if (type === 'insert' && batch.type === 'size') {\n        batch.type = 'insert';\n        batch.rows = [];\n      } else if (type === 'size' && batch.type === 'insert') {\n        // that's ok - go ahead and update size on the insert batch\n      } else {\n        batch = q[len] = createBatch(type);\n      }\n    }\n\n    return batch;\n  }\n}\n\nfunction createBatch(type) {\n  switch (type) {\n    case 'rowset':\n      return { type, rows: [] };\n    case 'update':\n      return { type, updates: [] };\n    case 'insert':\n      return { type, rows: [] };\n    case 'size':\n      return { type };\n    default:\n      throw Error('Unknown batch type');\n  }\n}\n", "import { RowSet, GroupRowSet } from './rowset/index';\nimport { addFilter, DataTypes, IN, getFilterType, resetRange } from '@vuu-ui/utils';\nimport UpdateQueue from './update-queue';\n\nconst DEFAULT_INDEX_OFFSET = 0;\nconst WITH_STATS = true;\nexport default class DataStore {\n  constructor(\n    table,\n    { columns = [], sortCriteria = null, groupBy = null, filter = null },\n    updateQueue = new UpdateQueue()\n  ) {\n    this._table = table;\n    this._index_offset = DEFAULT_INDEX_OFFSET;\n    this._filter = filter;\n    this._groupState = null;\n    this._sortCriteria = sortCriteria;\n\n    this.columns = columns;\n\n    this._groupby = groupBy;\n    this._update_queue = updateQueue;\n\n    this.reset = this.reset.bind(this);\n    this.rowUpdated = this.rowUpdated.bind(this);\n    this.rowsUpdated = this.rowsUpdated.bind(this);\n    this.rowInserted = this.rowInserted.bind(this);\n\n    this.reset();\n\n    table.on('ready', this.reset);\n    table.on('rowUpdated', this.rowUpdated);\n    table.on('rowsUpdated', this.rowsUpdated);\n    table.on('rowInserted', this.rowInserted);\n  }\n\n  destroy() {\n    this._table.removeListener('rowUpdated', this.rowUpdated);\n    this._table.removeListener('rowInserted', this.rowInserted);\n    this._table = null;\n    this.rowSet = null;\n    this.filterRowSet = null;\n    this._update_queue = null;\n  }\n\n  get status() {\n    return this._table.status;\n  }\n\n  get hasGroupBy() {\n    return this._groupby?.length;\n  }\n\n  reset() {\n    const { _table: table, _groupby: groupBy, rowSet } = this;\n\n    let range = rowSet ? rowSet.range : null;\n\n    // TODO we should pass yarn build into the rowset as it will be needed for computed columns\n    this.rowSet = new RowSet(table, this.columns, this._index_offset);\n    // Is one filterRowset enough, or should we manage one for each column ?\n    this.filterRowSet = null;\n\n    // What if data is BOTH grouped and sorted ...\n    if (groupBy !== null) {\n      // more efficient to compute this directly from the table projection\n      this.rowSet = new GroupRowSet(this.rowSet, this.columns, this._groupby, this._groupState);\n    } else if (this._sortCriteria !== null) {\n      this.rowSet.sort(this._sortCriteria);\n    }\n\n    if (range) {\n      const result = this.setRange(range, false);\n      console.log(result);\n      this._update_queue.replace(result);\n    }\n  }\n\n  rowInserted(event, idx, row) {\n    const { _update_queue, rowSet } = this;\n    const { size = null, replace, updates } = rowSet.insert(idx, row);\n    if (size !== null) {\n      _update_queue.resize(size);\n    }\n    if (replace) {\n      const { rows, size, offset } = rowSet.currentRange();\n      _update_queue.replace({ rows, size, offset, filter: undefined, range: undefined });\n    } else if (updates) {\n      updates.forEach((update) => {\n        _update_queue.update(update);\n      });\n    }\n    // what about offset change only ?\n  }\n\n  rowUpdated(event, idx, updates) {\n    const { rowSet, _update_queue } = this;\n    const result = rowSet.update(idx, updates);\n\n    if (result) {\n      if (rowSet instanceof RowSet) {\n        _update_queue.update(result);\n      } else {\n        result.forEach((rowUpdate) => {\n          _update_queue.update(rowUpdate);\n        });\n      }\n    }\n  }\n\n  rowsUpdated(event, updates, doNotPublish) {\n    const { rowSet, _update_queue } = this;\n    const results = [];\n    for (let i = 0; i < updates.length; i++) {\n      const [idx, ...updatedValues] = updates[i];\n      const result = rowSet.update(idx, updatedValues);\n      if (result) {\n        if (rowSet instanceof RowSet) {\n          results.push(result);\n        } else {\n          result.forEach((rowUpdate) => {\n            results.push(rowUpdate);\n          });\n        }\n      }\n    }\n\n    if (results.length > 0 && doNotPublish !== true) {\n      _update_queue.update(results);\n    }\n  }\n\n  getData(dataType) {\n    return dataType === DataTypes.ROW_DATA\n      ? this.rowSet\n      : dataType === DataTypes.FILTER_DATA\n      ? this.filterRowSet\n      : null;\n  }\n\n  setSubscribedColumns(columns) {\n    this.rowSet.setSubscribedColumns(columns);\n  }\n\n  //TODO we seem to get a setRange when we reverse sort order, is that correct ?\n  setRange(range, useDelta = true, dataType = DataTypes.ROW_DATA) {\n    return this.getData(dataType).setRange(range, useDelta);\n  }\n\n  select(selectedIndices, dataType = DataTypes.ROW_DATA) {\n    const rowset = this.getData(dataType);\n    return rowset.select(selectedIndices);\n    // if (dataType === DataTypes.ROW_DATA){\n    //     return this.selectResponse(updates, dataType, rowset);\n    // } else {\n    //     console.log(`[dataView] select on filterSet (range ${JSON.stringify(rowset.range)})`)\n    // we need to handle this case here, as the filter we construct depends on the selection details\n    // TODO we shouldn't be using the sortSet here, need an API method\n    // const value = rowset.getSelectedValue(idx);\n    // const isSelected = rowset.selected.rows.includes(idx);\n    // const filter = {\n    //     type: isSelected ? IN : NOT_IN,\n    //     colName: rowset.columnName,\n    //     values: [value]\n    // }\n    // this.applyFilterSetChangeToFilter(filter);\n\n    // if (updates.length > 0){\n    //     return {\n    //         dataType,\n    //         updates,\n    //         stats: rowset.stats\n    //     }\n    // }\n    // }\n  }\n\n  selectAll(dataType = DataTypes.ROW_DATA) {\n    const rowset = this.getData(dataType);\n    return this.selectResponse(rowset.selectAll(), dataType, rowset, true);\n  }\n\n  selectNone(dataType = DataTypes.ROW_DATA) {\n    const rowset = this.getData(dataType);\n    return this.selectResponse(rowset.selectNone(), dataType, rowset, false);\n  }\n\n  // Handle response to a selecAll / selectNode operation. This may be operating on\n  // the entire resultset, or a filtered subset\n  selectResponse(updates, dataType, rowset, allSelected) {\n    const updatesInViewport = updates.length > 0;\n    const { stats } = rowset;\n    if (dataType === DataTypes.ROW_DATA) {\n      if (updatesInViewport) {\n        return { updates };\n      }\n    } else {\n      const { totalSelected } = stats;\n\n      // Maybe defer the filter operation ?\n      if (totalSelected === 0) {\n        this.applyFilterSetChangeToFilter({ colName: rowset.columnName, type: IN, values: [] });\n        // } else if (totalSelected === totalRowCount) {\n        //   this.applyFilterSetChangeToFilter({ colName: rowset.columnName, type: NOT_IN, values: [] });\n      } else {\n        // we are not operating on the whole dataset, therefore it is a filtered subset\n        if (allSelected) {\n          this.applyFilterSetChangeToFilter({\n            colName: rowset.columnName,\n            type: IN,\n            values: rowset.values\n          });\n        }\n      }\n\n      // always return, as the stats might be needed\n      // if (updatesInViewport){\n      return {\n        dataType,\n        updates,\n        stats: rowset.stats\n      };\n      // }\n    }\n  }\n\n  sort(sortCriteria) {\n    this._sortCriteria = sortCriteria;\n    this.rowSet.sort(sortCriteria);\n    // assuming the only time we would not useDelta is when we want to reset ?\n    return this.setRange(resetRange(this.rowSet.range), false);\n  }\n\n  // filter may be called directly from client, in which case changes should be propagated, where\n  // appropriate, to any active filterSet(s). However, if the filterset has been changed, e.g. selection\n  // within a set, then filter applied here in consequence must not attempt to reset the same filterSet\n  // that originates the change.\n  filter(filter, dataType = 'rowData', incremental = false, ignoreFilterRowset = false) {\n    if (dataType === DataTypes.FILTER_DATA) {\n      return [undefined, this.filterFilterData(filter)];\n    } else {\n      if (incremental) {\n        filter = addFilter(this._filter, filter);\n      }\n      const { rowSet, _filter, filterRowSet } = this;\n      const { range } = rowSet;\n      this._filter = filter;\n      let filterResultset;\n\n      if (filter === null && _filter) {\n        rowSet.clearFilter();\n      } else if (filter) {\n        this.rowSet.filter(filter);\n      } else {\n        throw Error(`InMemoryView.filter setting null filter when we had no filter anyway`);\n      }\n\n      if (filterRowSet && dataType === DataTypes.ROW_DATA && !ignoreFilterRowset) {\n        if (filter) {\n          if (filterRowSet.type === DataTypes.FILTER_DATA) {\n            filterResultset = filterRowSet.setSelectedFromFilter(filter);\n          } else if (filterRowSet.type === DataTypes.FILTER_BINS) {\n            this.filterRowSet = rowSet.getBinnedValuesForColumn({\n              name: this.filterRowSet.columnName\n            });\n            filterResultset = this.filterRowSet.setRange();\n          }\n        } else {\n          // TODO examine this. Must be a more efficient way to reset counts in filterRowSet\n          const { columnName, range } = filterRowSet;\n          this.filterRowSet = rowSet.getDistinctValuesForColumn({ name: columnName });\n          filterResultset = this.filterRowSet.setRange(range, false);\n        }\n      }\n\n      const resultSet = {\n        ...this.rowSet.setRange(resetRange(range), false),\n        filter\n      };\n\n      return filterResultset ? [resultSet, filterResultset] : [resultSet];\n    }\n  }\n\n  //TODO merge with method above\n  filterFilterData(filter) {\n    const { filterRowSet } = this;\n    if (filterRowSet) {\n      if (filter === null) {\n        filterRowSet.clearFilter();\n      } else if (filter) {\n        filterRowSet.filter(filter);\n      }\n\n      return filterRowSet.setRange(resetRange(filterRowSet.range), false, WITH_STATS);\n    } else {\n      console.error(`[InMemoryView] filterfilterRowSet no filterRowSet`);\n    }\n  }\n\n  applyFilterSetChangeToFilter(partialFilter) {\n    const [result] = this.filter(partialFilter, DataTypes.ROW_DATA, true, true);\n    this._update_queue.replace(result);\n  }\n\n  applyFilter() {}\n\n  groupBy(groupby) {\n    const { rowSet, columns, _groupState, _sortCriteria, _groupby } = this;\n    this._groupby = groupby;\n    if (groupby.length === 0) {\n      this.rowSet = RowSet.fromGroupRowSet(this.rowSet);\n    } else {\n      if (_groupby === null) {\n        this.rowSet = new GroupRowSet(rowSet, columns, groupby, _groupState, _sortCriteria);\n      } else {\n        rowSet.groupBy(groupby);\n      }\n    }\n\n    return this.rowSet.currentRange();\n  }\n\n  toggleGroupState(treeKey) {\n    let groupState = { ...this._groupState };\n    if (groupState[treeKey]) {\n      delete groupState[treeKey];\n    } else {\n      groupState[treeKey] = true;\n    }\n    return groupState;\n  }\n\n  openTreeNode(treeKey) {\n    const newGroupState = this.toggleGroupState(treeKey);\n    return this.setGroupState(newGroupState);\n  }\n\n  closeTreeNode(treeKey) {\n    const newGroupState = this.toggleGroupState(treeKey);\n    return this.setGroupState(newGroupState);\n  }\n\n  setGroupState(groupState) {\n    this._groupState = groupState;\n    const { rowSet } = this;\n    rowSet.setGroupState(groupState);\n\n    return rowSet.setRange(rowSet.range, false);\n  }\n\n  get updates() {\n    const {\n      _update_queue,\n      rowSet: { range }\n    } = this;\n    let results = {\n      updates: _update_queue.popAll(),\n      range: {\n        lo: range.lo,\n        hi: range.hi\n      }\n    };\n    return results;\n  }\n\n  getFilterData(column, range) {\n    const { rowSet, filterRowSet, _filter: filter } = this;\n    // If our own dataset has been filtered by the column we want values for, we cannot use it, we have\n    // to go back to the source, using a filter which excludes the one in place on the target column.\n    const columnName = column.name;\n    const colDef = this.columns.find((col) => col.name === columnName);\n    // No this should be decided beforehand (on client)\n    const type = getFilterType(colDef);\n\n    if (type === 'number') {\n      // // we need a notification from server to tell us when this is closed.\n      // we should assign to filterRowset\n      this.filterRowSet = rowSet.getBinnedValuesForColumn(column);\n    } else if (!filterRowSet || filterRowSet.columnName !== column.name) {\n      this.filterRowSet = rowSet.getDistinctValuesForColumn(column);\n    } else if (filterRowSet && filterRowSet.columnName === column.name) {\n      // if we already have the data for this filter, nothing further to do except reset the filterdata range\n      // so next request will return full dataset.\n      filterRowSet.setRange({ lo: 0, hi: 0 });\n    }\n    // If we already have a filterRowset for this column, but a filter on another column has changed, we need to\n    // recreate the filterRowset: SHould this happen when filter happens ?\n\n    if (filter) {\n      this.filterRowSet.setSelectedFromFilter(filter);\n    } else {\n      this.filterRowSet.selectAll();\n    }\n\n    // do we need to returtn searchText ? If so, it should\n    // be returned by the rowSet\n\n    // TODO wrap this, we use it  alot\n    return this.filterRowSet.setRange(range, false, WITH_STATS);\n  }\n}\n", "import BaseTable from './table';\n\nexport default class Table extends BaseTable {\n  constructor({ valueColumns, ...config }) {\n    super(config);\n    this.valueColumns = valueColumns; // updateableFields ?\n  }\n\n  setData(data) {\n    const { index } = this;\n    for (let i = 0; i < data.length; i++) {\n      const [idx, key] = data[i];\n      index[key] = idx;\n    }\n\n    this.rows = data;\n  }\n\n  async loadData(dataUrl) {\n    console.log(`import data from ${dataUrl}.js`);\n    try {\n      const { default: data } = await import(`${dataUrl}`);\n      if (data) {\n        this.setData(data);\n      }\n    } catch (e) {\n      console.error(`failed to load data from path '${dataUrl}'`, e);\n    }\n  }\n\n  // async installDataGenerators({createPath, updatePath}){\n  //     if (createPath){\n  //         const {default:createGenerator} = await import(`${createPath}.mjs`);\n  //         this.createRow = createGenerator;\n  //     }\n  //     if (updatePath){\n  //         const {default: updateGenerator} = await import(`${updatePath}.mjs`);\n  //         this.updateRow = updateGenerator;\n  //     }\n  // }\n}\n", "const NO_COLUMNS = [];\nconst NO_FILTER = { filter: '' };\nconst NO_SORT = { sortDefs: [] };\n\nexport const viewportChanges = (\n  {\n    columns: currentColumns = NO_COLUMNS,\n    filterSpec: currentFilterSpec = NO_FILTER,\n    groupBy: currentGroupBy = NO_COLUMNS,\n    sort: currentSort = NO_SORT\n  },\n  {\n    columns: newColumns = NO_COLUMNS,\n    filterSpec: newFilterSpec = NO_FILTER,\n    groupBy: newGroupBy = NO_COLUMNS,\n    sort: newSort = NO_SORT\n  }\n) => {\n  const result = {};\n  if (!sameColumns(currentColumns, newColumns)) {\n    result.columns = true;\n  }\n\n  if (!sameSort(currentSort, newSort)) {\n    result.sort = true;\n  }\n\n  if (!sameColumns(currentGroupBy, newGroupBy)) {\n    result.groupBy = true;\n  }\n\n  if (currentFilterSpec.filter !== newFilterSpec.filter) {\n    result.filter = true;\n  }\n\n  return result;\n};\n\nfunction sameColumns(currentColumns, newColumns) {\n  if (currentColumns.length !== newColumns.length) {\n    return false;\n  }\n  if (\n    currentColumns.some(\n      ({ column, sortType }) =>\n        !newColumns.find((colDef) => colDef.column === column && colDef.sortType === sortType)\n    )\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction sameSort({ sortDefs: currentSortDefs }, { sortDefs: newSortDefs }) {\n  if (currentSortDefs.length !== newSortDefs.length) {\n    return false;\n  }\n  if (\n    currentSortDefs.some(({ col, dir }, i) => {\n      const { col: newCol, dir: newDir } = newSortDefs[i];\n      return newCol === col && newDir === dir;\n    })\n  ) {\n    return false;\n  }\n\n  return true;\n}\n", "import { createLogger, logColor } from '@vuu-ui/utils/src/logging';\nimport { AND, OR, EQUALS, GREATER_THAN, LESS_THAN, IN } from '@vuu-ui/utils/src/filter-utils';\n\nimport DataStore from './data-store';\nimport Table from './worker-table';\nimport { viewportChanges } from './data-store-utils';\n\nconst logger = createLogger('DataStoreConnection', logColor.brown);\n\nconst OP_TO_FILTER_TYPE = {\n  and: AND,\n  or: OR,\n  '=': EQUALS,\n  '>': GREATER_THAN,\n  '<': LESS_THAN,\n  in: IN\n};\n\nconst filterFromQuery = (filter) => {\n  const { column, op, value, values, filters } = filter;\n  if (filters) {\n    return {\n      type: OP_TO_FILTER_TYPE[op],\n      filters: filters.map(filterFromQuery)\n    };\n  } else {\n    return {\n      type: OP_TO_FILTER_TYPE[op],\n      colName: column,\n      value,\n      values\n    };\n  }\n};\n\nexport default async function connectDataStore(connectionString, callback) {\n  return makeConnection(connectionString, (msg) => {\n    callback(msg);\n  });\n}\n\nasync function makeConnection(url, callback, connection) {\n  callback({ type: 'connection-status', status: 'connecting' });\n  const dataStore = await createDataStore(url);\n\n  // console.log(\n  //   `%c\u26A1 ${url}`,\n  //   'padding-left: 6px;font-size: 16px;color: yellow; background-color:black',\n  // );\n\n  connection = new DataStoreConnection(dataStore, url, callback);\n  const status = 'connected';\n  callback({ type: 'connection-status', status });\n  connection.status = status;\n  return connection;\n}\n\nconst createDataStore = async (url) => {\n  console.log(`table config url ${url}`);\n  const loadTableConfiguration = async () => await import(url);\n\n  const { config } = await loadTableConfiguration();\n  console.log(`got config ${JSON.stringify(config, null, 2)}`);\n  const { generateData } = await import(config.dataUrl);\n  const table = new Table(config);\n  table.setData(generateData());\n  return new DataStore(table, { columns: config.columns } /*, updateQueue*/);\n};\n\nclass DataStoreConnection {\n  constructor(dataStore, url, callback) {\n    this.url = url;\n    this.connectionCallback = callback;\n    this.viewPortId = undefined;\n    this.setDataStore(dataStore);\n    this.status = 'ready';\n    this.viewportMeta = null;\n  }\n\n  setDataStore(dataStore) {\n    const { connectionCallback: callback } = this;\n\n    const send = (msg, options) => {\n      // console.log(\n      //   `%c>>>  (DataStoreConnection) ${JSON.stringify(msg)} ${JSON.stringify(\n      //     options,\n      //   )}`,\n      //   'color:blue;font-weight:bold;',\n      // );\n      const { requestId, body } = msg;\n      switch (body.type) {\n        case 'CREATE_VP':\n          {\n            const viewPortId = (this.viewPortId = requestId);\n            const { columns, filterSpec, groupBy, sort, range, table } = body;\n            callback({\n              requestId,\n              body: {\n                type: 'CREATE_VP_SUCCESS',\n                viewPortId,\n                columns,\n                range,\n                table\n              }\n            });\n            const { rows, size: vpSize } = dataStore.setRange(\n              { lo: range.from, hi: range.to },\n              true\n            );\n            const ts = +new Date();\n            callback({\n              requestId: 'NA',\n              body: {\n                type: 'TABLE_ROW',\n                timeStamp: ts,\n                rows: [\n                  {\n                    viewPortId,\n                    vpSize,\n                    rowIndex: -1,\n                    rowKey: 'SIZE',\n                    updateType: 'SIZE',\n                    sel: 0,\n                    ts,\n                    data: []\n                  }\n                ].concat(\n                  rows.map(([rowIndex, , , , , , rowKey, sel, ...data]) => ({\n                    viewPortId,\n                    vpSize,\n                    rowIndex,\n                    rowKey,\n                    updateType: 'U',\n                    sel,\n                    ts,\n                    data\n                  }))\n                )\n              }\n            });\n            this.viewportMeta = { columns, filterSpec, groupBy, sort };\n          }\n          break;\n\n        case 'CHANGE_VP_RANGE':\n          {\n            const { from, to, viewPortId } = body;\n            callback({\n              requestId,\n              body: { type: 'CHANGE_VP_RANGE_SUCCESS', viewPortId, from, to }\n            });\n            const { rows, size } = dataStore.setRange({ lo: from, hi: to }, true);\n            if (dataStore.hasGroupBy) {\n              callback(groupedRows(viewPortId, rows, size));\n            } else {\n              callback(leafRows(viewPortId, rows, size));\n            }\n          }\n          break;\n\n        case 'CHANGE_VP':\n          {\n            const { type, viewPortId, ...viewportMeta } = body;\n            const diff = viewportChanges(this.viewportMeta, viewportMeta);\n            this.viewportMeta = viewportMeta;\n            callback({\n              requestId,\n              body: { type: 'CHANGE_VP_SUCCESS', viewPortId }\n            });\n            if (diff.filter) {\n              const filter = filterFromQuery(options.filter);\n              const [{ rows, size }] = dataStore.filter(filter);\n              if (dataStore.hasGroupBy) {\n                callback(groupedRows(viewPortId, rows, size));\n              } else {\n                callback(leafRows(viewPortId, rows, size));\n              }\n            } else if (diff.sort) {\n              const sortCriteria = body.sort.sortDefs.map(({ column, sortType }) => [\n                column,\n                sortType === 'D' ? 'dsc' : 'asc'\n              ]);\n              const { rows, size } = dataStore.sort(sortCriteria);\n              if (dataStore.hasGroupBy) {\n                callback(groupedRows(viewPortId, rows, size));\n              } else {\n                callback(leafRows(viewPortId, rows, size));\n              }\n            } else if (diff.groupBy) {\n              const { rows, size } = dataStore.groupBy(body.groupBy);\n              if (body.groupBy.length > 0) {\n                callback(groupedRows(viewPortId, rows, size));\n              } else {\n                callback(leafRows(viewPortId, rows, size));\n              }\n            }\n          }\n          break;\n\n        case 'SET_SELECTION':\n          {\n            const { viewPortId } = this;\n            const { rows } = dataStore.select(body.selection);\n            callback(leafRows(viewPortId, rows));\n          }\n          break;\n\n        case 'OPEN_TREE_NODE':\n          {\n            const { viewPortId } = this;\n            const { rows, size } = dataStore.openTreeNode(body.treeKey);\n            callback(groupedRows(viewPortId, rows, size));\n          }\n          break;\n        case 'CLOSE_TREE_NODE':\n          {\n            const { viewPortId } = this;\n            const { rows, size } = dataStore.closeTreeNode(body.treeKey);\n            callback(groupedRows(viewPortId, rows, size));\n          }\n          break;\n\n        default:\n          logger.log(`Unknown message type from client ${body.type}`);\n      }\n    };\n\n    this.send = send;\n\n    const warn = (msg) => {\n      logger.log(`Message cannot be sent, socket closed: ${msg.type}`);\n    };\n\n    this.close = () => {\n      console.log('[Connection] close dataStoreConnection');\n      this.status = 'closed';\n      this.send = warn;\n    };\n  }\n}\n\nfunction leafRows(viewPortId, rows, size) {\n  const ts = +new Date();\n  return {\n    requestId: 'NA',\n    body: {\n      type: 'TABLE_ROW',\n      timeStamp: ts,\n      rows: rows.map(([rowIndex, , , , , , rowKey, sel, ...data]) => ({\n        viewPortId,\n        vpSize: size,\n        rowIndex,\n        rowKey,\n        updateType: 'U',\n        sel,\n        ts,\n        data\n      }))\n    }\n  };\n}\n\nfunction groupedRows(viewPortId, rows, size) {\n  const ts = +new Date();\n  return {\n    requestId: 'NA',\n    body: {\n      type: 'TABLE_ROW',\n      timeStamp: ts,\n      rows: [\n        {\n          viewPortId,\n          vpSize: size,\n          rowIndex: -1,\n          rowKey: 'SIZE',\n          updateType: 'SIZE',\n          sel: 0,\n          ts,\n          data: []\n        }\n      ].concat(\n        rows.map(([rowIndex, , isLeaf, isExpanded, depth, count, rowKey, sel, ...data]) => ({\n          viewPortId,\n          vpSize: size,\n          rowIndex,\n          rowKey,\n          updateType: 'U',\n          sel,\n          ts,\n          data: [Math.abs(depth), isExpanded, rowKey, isLeaf, '', count, ...data]\n        }))\n      )\n    }\n  };\n}\n", "const data = [];\n\nconst HB = /\"HB\"/;\nconst AUTH_SUCCESS = /\"AUTH_SUCCESS\"/;\nconst LOGIN_SUCCESS = /\"LOGIN_SUCCESS\"/;\nconst TABLE_LIST = /TABLE_LIST/;\nconst TABLE_META = /TABLE_META/;\n\nexport const saveTestData = (message, source) => {\n  if (\n    source === 'server' &&\n    (HB.test(message) ||\n      AUTH_SUCCESS.test(message) ||\n      LOGIN_SUCCESS.test(message) ||\n      TABLE_LIST.test(message) ||\n      TABLE_META.test(message))\n  ) {\n    return;\n  } else if (source === 'client') {\n    if (message.type.startsWith('GET_TABLE_')) {\n      return;\n    }\n\n    message = JSON.stringify(message);\n  }\n  data.push(message);\n};\n\nexport const getTestMessages = () => {\n  const messages = data.slice();\n  data.length = 0;\n  return messages;\n};\n", "export const AUTH = 'AUTH';\nexport const AUTH_SUCCESS = 'AUTH_SUCCESS';\nexport const CHANGE_VP = 'CHANGE_VP';\nexport const CHANGE_VP_SUCCESS = 'CHANGE_VP_SUCCESS';\nexport const CHANGE_VP_RANGE = 'CHANGE_VP_RANGE';\nexport const CHANGE_VP_RANGE_SUCCESS = 'CHANGE_VP_RANGE_SUCCESS';\nexport const CLOSE_TREE_NODE = 'CLOSE_TREE_NODE';\nexport const CLOSE_TREE_SUCCESS = 'CLOSE_TREE_SUCCESS';\nexport const CLOSE_TREE_REJECT = 'CLOSE_TREE_REJECT';\nexport const CREATE_VISUAL_LINK = 'CREATE_VISUAL_LINK';\nexport const CREATE_VISUAL_LINK_SUCCESS = 'CREATE_VISUAL_LINK_SUCCESS';\nexport const CREATE_VP = 'CREATE_VP';\nexport const CREATE_VP_SUCCESS = 'CREATE_VP_SUCCESS';\nexport const DISABLE_VP = 'DISABLE_VP';\nexport const DISABLE_VP_SUCCESS = 'DISABLE_VP_SUCCESS';\nexport const DISABLE_VP_REJECT = 'DISABLE_VP_REJECT';\nexport const ENABLE_VP = 'ENABLE_VP';\nexport const ENABLE_VP_SUCCESS = 'ENABLE_VP_SUCCESS';\nexport const ENABLE_VP_REJECT = 'ENABLE_VP_REJECT';\nexport const GET_TABLE_LIST = 'GET_TABLE_LIST';\nexport const GET_TABLE_META = 'GET_TABLE_META';\nexport const GET_VP_VISUAL_LINKS = 'GET_VP_VISUAL_LINKS';\nexport const GET_VIEW_PORT_MENUS = 'GET_VIEW_PORT_MENUS';\nexport const VIEW_PORT_MENUS_RESP = 'VIEW_PORT_MENUS_RESP';\nexport const VIEW_PORT_MENUS_SELECT_RPC = 'VIEW_PORT_MENUS_SELECT_RPC';\nexport const VIEW_PORT_MENU_CELL_RPC = 'VIEW_PORT_MENU_CELL_RPC';\nexport const VIEW_PORT_MENU_TABLE_RPC = 'VIEW_PORT_MENU_TABLE_RPC';\nexport const VIEW_PORT_MENU_ROW_RPC = 'VIEW_PORT_MENU_ROW_RPC';\nexport const VIEW_PORT_MENU_RESP = 'VIEW_PORT_MENU_RESP';\nexport const VIEW_PORT_MENU_REJ = 'VIEW_PORT_MENU_REJ';\nexport const HB = 'HB';\nexport const HB_RESP = 'HB_RESP';\nexport const LOGIN = 'LOGIN';\nexport const LOGIN_SUCCESS = 'LOGIN_SUCCESS';\nexport const OPEN_TREE_NODE = 'OPEN_TREE_NODE';\nexport const OPEN_TREE_SUCCESS = 'OPEN_TREE_SUCCESS';\nexport const OPEN_TREE_REJECT = 'OPEN_TREE_REJECT';\nexport const REMOVE_VP = 'REMOVE_VP';\nexport const REMOVE_VP_SUCCESS = 'REMOVE_VP_SUCCESS';\nexport const REMOVE_VP_REJECT = 'REMOVE_VP_REJECT';\nexport const RPC_CALL = 'RPC_CALL';\nexport const RPC_RESP = 'RPC_RESP';\nexport const MENU_RPC_CALL = 'MENU_RPC_CALL';\nexport const MENU_RPC_RESP = 'MENU_RPC_RESP';\nexport const SET_SELECTION = 'SET_SELECTION';\nexport const SET_SELECTION_SUCCESS = 'SET_SELECTION_SUCCESS';\nexport const TABLE_META_RESP = 'TABLE_META_RESP';\nexport const TABLE_LIST_RESP = 'TABLE_LIST_RESP';\nexport const VP_VISUAL_LINKS_RESP = 'VP_VISUAL_LINKS_RESP';\n\nexport const TABLE_ROW = 'TABLE_ROW';\nexport const SIZE = 'SIZE';\nexport const UPDATE = 'U';\n\nexport const authRequest = (username: string, password: string) => ({ type: AUTH, username, password });\nexport const loginRequest = (token: string, user: string) => ({ type: LOGIN, token, user });\nexport const getVisualLinks = (vpId: string) => ({ type: GET_VP_VISUAL_LINKS, vpId });\nexport const getViewportMenus = (vpId: string) => ({ type: GET_VIEW_PORT_MENUS, vpId });\n", "import {VuuRange} from \"../../../../utils/src/range-utils\";\nimport {FromToRange} from \"./buffer-range\";\n\nexport class KeySet {\n  private keys: Map<number, number>;\n  private free: number[];\n  private nextKeyValue: number;\n\n  constructor(range: VuuRange) {\n    this.keys = new Map();\n    this.free = [];\n    this.nextKeyValue = 0;\n    if (range) {\n      const { lo, hi, from = lo, to = hi } = range;\n      this.reset({ from, to });\n    }\n  }\n\n  public next(): number {\n    if (this.free.length) {\n      return this.free.pop();\n    } else {\n      return this.nextKeyValue++;\n    }\n  }\n\n  public reset({ from, to }: FromToRange) {\n    this.keys.forEach((keyValue, rowIndex) => {\n      if (rowIndex < from || rowIndex >= to) {\n        this.free.push(keyValue);\n        this.keys.delete(rowIndex);\n      }\n    });\n\n    const size = to - from;\n    if (this.keys.size + this.free.length > size) {\n      this.free.length = size - this.keys.size;\n    }\n\n    for (let rowIndex = from; rowIndex < to; rowIndex++) {\n      if (!this.keys.has(rowIndex)) {\n        const nextKeyValue = this.next();\n        this.keys.set(rowIndex, nextKeyValue);\n      }\n    }\n  }\n\n  public keyFor(rowIndex: number): number {\n    return this.keys.get(rowIndex);\n  }\n}\n", "export interface FromToRange {\n  from: number;\n  to: number;\n}\n\nexport const bufferBreakout = (range: FromToRange, from: number, to: number, bufferSize: number): boolean => {\n  const bufferPerimeter = bufferSize * 0.25;\n  if (!range || !bufferSize) {\n    return true;\n  } else if (range.to - to < bufferPerimeter) {\n    return true;\n  } else if (range.from > 0 && from - range.from < bufferPerimeter) {\n    return true;\n  } else {\n    return false;\n  }\n};\n", "import { WindowRange } from '@vuu-ui/utils/src/range-utils';\nimport {bufferBreakout, FromToRange} from './buffer-range';\nimport {LoHiRange} from \"../viewserver/server-proxy\";\n\nexport class ArrayBackedMovingWindow {\n  private bufferSize: number;\n  private clientRange: WindowRange;\n  private range: WindowRange;\n  private internalData: any[];\n  private rowsWithinRange: number;\n  private rowCount: number;\n\n  // Note, the buffer is already accounted for in the range passed in here\n  constructor({ lo, hi }: LoHiRange, { from, to }: FromToRange, bufferSize: number) {\n    this.bufferSize = bufferSize;\n    this.clientRange = new WindowRange(lo, hi);\n    this.range = new WindowRange(from, to);\n    //internal data is always 0 based, we add range.from to determine an offset\n    this.internalData = new Array(bufferSize);\n    this.rowsWithinRange = 0;\n    this.rowCount = 0;\n  }\n\n  // TODO we shpuld probably have a hasAllClientRowsWithinRange\n  get hasAllRowsWithinRange(): boolean {\n    return (\n      this.rowsWithinRange === this.clientRange.to - this.clientRange.from ||\n      // this.rowsWithinRange === this.range.to - this.range.from ||\n      (this.rowCount > 0 && this.rowsWithinRange === this.rowCount)\n    );\n  }\n\n  setRowCount = (rowCount: number) => {\n    if (rowCount < this.internalData.length) {\n      this.internalData.length = rowCount;\n    }\n    if (rowCount < this.rowCount) {\n      // Brute force, works\n      this.rowsWithinRange = 0;\n      const end = Math.min(rowCount, this.clientRange.to);\n      for (let i = this.clientRange.from; i < end; i++) {\n        const rowIndex = i - this.range.from;\n        if (this.internalData[rowIndex] !== undefined) {\n          this.rowsWithinRange += 1;\n        }\n      }\n    }\n    this.rowCount = rowCount;\n  };\n\n  setAtIndex(index: number, data: any) {\n    const isWithinClientRange = this.isWithinClientRange(index);\n    if (isWithinClientRange || this.isWithinRange(index)) {\n      const internalIndex = index - this.range.from;\n      if (!this.internalData[internalIndex] && isWithinClientRange) {\n        this.rowsWithinRange += 1;\n        //onsole.log(`rowsWithinRange is now ${this.rowsWithinRange} out of ${this.range.to - this.range.from}`)\n      }\n      this.internalData[internalIndex] = data;\n    }\n    return isWithinClientRange;\n  }\n\n  getAtIndex(index: number): any {\n    return this.range.isWithin(index) && this.internalData[index - this.range.from] != null\n      ? this.internalData[index - this.range.from]\n      : undefined;\n  }\n\n  isWithinRange(index: number): boolean {\n    return this.range.isWithin(index);\n  }\n\n  isWithinClientRange(index: number): boolean {\n    return this.clientRange.isWithin(index);\n  }\n\n  // Returns [false] or [serverDataRequired, clientRows, holdingRows]\n  setClientRange(from: number, to: number): [boolean] | [boolean, any[], any[]] {\n    const currentFrom = this.clientRange.from;\n    const currentTo = Math.min(this.clientRange.to, this.rowCount);\n\n    if (from === currentFrom && to === currentTo) {\n      return [false];\n    }\n\n    const originalRange = this.clientRange.copy();\n    this.clientRange.from = from;\n    this.clientRange.to = to;\n    this.rowsWithinRange = 0;\n    for (let i = from; i < to; i++) {\n      const internalIndex = i - this.range.from;\n      if (this.internalData[internalIndex]) {\n        this.rowsWithinRange += 1;\n      }\n    }\n\n    let clientRows = undefined;\n    let holdingRows = undefined;\n    const offset = this.range.from;\n\n    if (this.hasAllRowsWithinRange) {\n      if (to > originalRange.to) {\n        const start = Math.max(from, originalRange.to);\n        clientRows = this.internalData.slice(start - offset, to - offset);\n      } else {\n        const end = Math.min(originalRange.from, to);\n        clientRows = this.internalData.slice(from - offset, end - offset);\n      }\n    } else if (this.rowsWithinRange > 0) {\n      if (to > originalRange.to) {\n        const start = Math.max(from, originalRange.to);\n        holdingRows = this.internalData.slice(start - offset, to - offset).filter((row) => !!row);\n      } else {\n        const end = Math.min(originalRange.from, to);\n        holdingRows = this.internalData\n          .slice(Math.max(0, from - offset), end - offset)\n          .filter((row) => !!row);\n      }\n    }\n\n    const serverDataRequired = bufferBreakout(this.range, from, to, this.bufferSize);\n    return [serverDataRequired, clientRows, holdingRows];\n  }\n\n  setRange(from: number, to: number) {\n    const [overlapFrom, overlapTo] = this.range.overlap(from, to);\n\n    const newData = new Array(to - from + this.bufferSize);\n    this.rowsWithinRange = 0;\n\n    for (let i = overlapFrom; i < overlapTo; i++) {\n      const data = this.getAtIndex(i);\n      if (data) {\n        const index = i - from;\n        newData[index] = data;\n        if (this.isWithinClientRange(i)) {\n          this.rowsWithinRange += 1;\n        }\n      }\n    }\n\n    this.internalData = newData;\n    this.range.from = from;\n    this.range.to = to;\n  }\n\n  getData(): any[] {\n    const { from, to } = this.range;\n    const { from: lo, to: hi } = this.clientRange;\n    const startOffset = Math.max(0, lo - from);\n    // TEMP hack, whu wouldn't we have rowCount ?\n    const endOffset = Math.min(to - from, to, hi - from, this.rowCount ?? to);\n    // const endOffset = Math.min(to-from, to, hi - from, this.rowCount);\n    return this.internalData.slice(startOffset, endOffset);\n  }\n}\n", "import { KeySet } from './keyset';\nimport * as Message from './messages';\nimport { ArrayBackedMovingWindow } from './array-backed-moving-window';\nimport { getFullRange } from '@vuu-ui/utils/src/range-utils';\nimport { bufferBreakout } from './buffer-range';\n\nconst EMPTY_ARRAY = [];\n\nconst byRowIndex = ([index1], [index2]) => index1 - index2;\nexport class Viewport {\n  constructor({\n    viewport,\n    tablename,\n    aggregations,\n    columns,\n    range,\n    bufferSize = 0,\n    filter = '',\n    filterQuery = '',\n    sort = [],\n    groupBy = [],\n    visualLink\n  }) {\n    this.clientViewportId = viewport;\n    this.table = tablename;\n    this.status = '';\n    this.disabled = false;\n    this.suspended = false;\n    this.aggregations = aggregations;\n    this.columns = columns;\n    this.clientRange = range;\n    this.bufferSize = bufferSize;\n    this.sort = {\n      sortDefs: sort\n    };\n    this.groupBy = groupBy;\n    this.filterSpec = {\n      filter: filterQuery\n    };\n    this.filter = filter;\n    this.isTree = false;\n    this.dataWindow = undefined;\n    this.rowCountChanged = false;\n    this.keys = new KeySet(range);\n    this.links = null;\n    this.linkedParent = null;\n    this.pendingLinkedParent = visualLink;\n    this.pendingOperations = new Map();\n    this.pendingRangeRequest = null;\n    this.hasUpdates = false;\n    this.holdingPen = [];\n    this.selection = [];\n    this.lastTouchIdx = null;\n  }\n\n  get hasUpdatesToProcess() {\n    if (this.suspended) {\n      return false;\n    }\n    return this.rowCountChanged || this.hasUpdates;\n  }\n\n  subscribe() {\n    return {\n      type: Message.CREATE_VP,\n      table: this.table,\n      range: getFullRange(this.clientRange, this.bufferSize),\n      aggregations: this.aggregations,\n      columns: this.columns,\n      sort: this.sort,\n      groupBy: this.groupBy,\n      filterSpec: this.filterSpec\n    };\n  }\n\n  handleSubscribed({ viewPortId, aggregations, columns, table, range, sort, groupBy, filterSpec }) {\n    this.serverViewportId = viewPortId;\n    this.status = 'subscribed';\n    this.aggregations = aggregations;\n    this.columns = columns;\n    this.table = table;\n    this.range = range;\n    this.sort = sort;\n    this.groupBy = groupBy;\n    this.filterSpec = filterSpec;\n    this.isTree = groupBy && groupBy.length > 0;\n    this.dataWindow = new ArrayBackedMovingWindow(this.clientRange, range, this.bufferSize);\n\n    console.log(\n      `%cViewport subscribed\n        clientVpId: ${this.clientViewportId}\n        serverVpId: ${this.serverViewportId}\n        table: ${this.table}\n        aggregations: ${JSON.stringify(aggregations)}\n        columns: ${columns.join(',')}\n        range: ${JSON.stringify(range)}\n        sort: ${JSON.stringify(sort)}\n        groupBy: ${JSON.stringify(groupBy)}\n        filterSpec: ${JSON.stringify(filterSpec)}\n        bufferSize: ${this.bufferSize}\n      `,\n      'color: blue'\n    );\n\n    return {\n      type: 'subscribed',\n      clientViewportId: this.clientViewportId,\n      columns,\n      filter: this.filter,\n      filterSpec: this.filterSpec\n    };\n  }\n\n  awaitOperation(requestId, type) {\n    //TODO set uip a timeout mechanism here\n    this.pendingOperations.set(requestId, type);\n  }\n\n  // Return a message if we need to communicate this to client UI\n  completeOperation(requestId, ...params) {\n    const { clientViewportId, pendingOperations } = this;\n    const { type, data } = pendingOperations.get(requestId);\n    pendingOperations.delete(requestId);\n    if (type === Message.CHANGE_VP_RANGE) {\n      const [from, to] = params;\n      this.dataWindow.setRange(from, to);\n      //this.hasUpdates = true; // is this right ??????????\n      this.pendingRangeRequest = null;\n    } else if (type === 'groupBy') {\n      this.isTree = true;\n      this.groupBy = data;\n      return { clientViewportId, type, groupBy: data };\n    } else if (type === 'groupByClear') {\n      this.isTree = false;\n      this.groupBy = [];\n      return { clientViewportId, type: 'groupBy', groupBy: null };\n    } else if (type === 'filter') {\n      this.filterSpec = { filter: data.filterQuery };\n      return { clientViewportId, type, ...data };\n    } else if (type === 'aggregate') {\n      this.aggregations = data;\n      return { clientViewportId, type, aggregations: data };\n    } else if (type === 'sort') {\n      this.sort = { sortDefs: data };\n      return { clientViewportId, type, sort: data };\n    } else if (type === 'selection') {\n      // should we do this here ?\n      // this.selection = data;\n    } else if (type === 'disable') {\n      this.disabled = true; // assuming its _SUCCESS, of course\n      return {\n        type: 'disabled',\n        clientViewportId\n      };\n    } else if (type === 'enable') {\n      this.disabled = false;\n      return {\n        type: 'enabled',\n        clientViewportId\n      };\n    } else if (type === Message.CREATE_VISUAL_LINK) {\n      const [colName, parentViewportId, parentColName] = params;\n      this.linkedParent = {\n        colName,\n        parentViewportId,\n        parentColName\n      };\n      this.pendingLinkedParent = null;\n      return {\n        type: 'visual-link-created',\n        clientViewportId,\n        colName,\n        parentViewportId,\n        parentColName\n      };\n    }\n  }\n\n  rangeRequest(requestId, from, to) {\n    // If we can satisfy the range request from the buffer, we will.\n    // May or may not need to make a server request, depending on status of buffer\n    const type = Message.CHANGE_VP_RANGE;\n    // If dataWindow has all data for the new range, it will return the\n    // delta of rows which are in the new range but were not in the\n    // previous range.\n    // Note: what if it doesn't have the entire range but DOES have all\n    // rows that constitute the delta ? Is this even possible ?\n    const [serverDataRequired, clientRows, holdingRows] = this.dataWindow.setClientRange(from, to);\n    const serverRequest =\n      serverDataRequired && bufferBreakout(this.pendingRangeRequest, from, to, this.bufferSize)\n        ? {\n            type,\n            viewPortId: this.serverViewportId,\n            ...getFullRange({ lo: from, hi: to }, this.bufferSize, this.dataWindow.rowCount)\n          }\n        : undefined;\n    if (serverRequest) {\n      // TODO check that there os not already a pending server request for more data\n      this.awaitOperation(requestId, { type });\n      this.pendingRangeRequest = serverRequest;\n    }\n\n    // always reset the keys here, even if we're not going to return rows immediately.\n    this.keys.reset(this.dataWindow.clientRange);\n\n    if (this.holdingPen.some(([index]) => index < from || index >= to)) {\n      this.holdingPen = this.holdingPen.filter(([index]) => index >= from && index < to);\n    }\n\n    const toClient = this.isTree ? toClientRowTree(this.groupBy, this.columns) : toClientRow;\n\n    if (holdingRows) {\n      holdingRows.forEach((row) => {\n        this.holdingPen.push(toClient(row, this.keys));\n      });\n    }\n\n    if (clientRows) {\n      return [serverRequest, clientRows.map((row) => toClient(row, this.keys))];\n    } else {\n      return [serverRequest];\n    }\n  }\n\n  setLinks(links) {\n    this.links = links;\n    return [\n      {\n        type: 'VP_VISUAL_LINKS_RESP',\n        links,\n        clientViewportId: this.clientViewportId\n      },\n      this.pendingLinkedParent\n    ];\n  }\n\n  setMenu(menu) {\n    return {\n      type: 'VIEW_PORT_MENUS_RESP',\n      menu,\n      clientViewportId: this.clientViewportId\n    };\n  }\n\n  createLink(requestId, colName, parentVpId, parentColumnName) {\n    const message = {\n      type: Message.CREATE_VISUAL_LINK,\n      parentVpId,\n      childVpId: this.serverViewportId,\n      parentColumnName,\n      childColumnName: colName\n    };\n    this.awaitOperation(requestId, message);\n    return message;\n  }\n\n  suspend() {\n    this.suspended = true;\n  }\n\n  resume() {\n    this.suspended = false;\n    return this.currentData();\n  }\n\n  currentData() {\n    const records = this.dataWindow.getData();\n    const { keys } = this;\n    const toClient = this.isTree ? toClientRowTree(this.groupBy, this.columns) : toClientRow;\n    const out = [];\n    for (let row of records) {\n      if (row) {\n        out.push(toClient(row, keys));\n      }\n    }\n    return out;\n  }\n\n  enable(requestId) {\n    this.awaitOperation(requestId, { type: 'enable' });\n    return {\n      type: Message.ENABLE_VP,\n      viewPortId: this.serverViewportId\n    };\n  }\n\n  disable(requestId) {\n    this.awaitOperation(requestId, { type: 'disable' });\n    return {\n      type: Message.DISABLE_VP,\n      viewPortId: this.serverViewportId\n    };\n  }\n\n  filterRequest(requestId, filter, filterQuery) {\n    this.awaitOperation(requestId, { type: 'filter', data: { filter, filterQuery } });\n    return this.createRequest({ filterSpec: { filter: filterQuery } });\n  }\n\n  aggregateRequest(requestId, aggregations) {\n    this.awaitOperation(requestId, { type: 'aggregate', data: aggregations });\n    return this.createRequest({ aggregations });\n  }\n\n  sortRequest(requestId, sortDefs) {\n    this.awaitOperation(requestId, { type: 'sort', data: sortDefs });\n    return this.createRequest({ sort: { sortDefs } });\n  }\n\n  groupByRequest(requestId, groupBy = EMPTY_ARRAY) {\n    const type = groupBy === EMPTY_ARRAY ? 'groupByClear' : 'groupBy';\n    this.awaitOperation(requestId, { type, data: groupBy });\n    return this.createRequest({ groupBy });\n  }\n\n  selectRequest(requestId, selection) {\n    // TODO we need to do this in the client if we are to raise selection events\n    // TODO is it right to set this here or should we wait for ACK from server ?\n    this.awaitOperation(requestId, { type: 'selection', data: selection });\n    return {\n      type: Message.SET_SELECTION,\n      vpId: this.serverViewportId,\n      selection\n    };\n  }\n\n  handleUpdate(updateType, rowIndex, row) {\n    if (this.dataWindow.rowCount !== row.vpSize) {\n      this.dataWindow.setRowCount(row.vpSize);\n      this.rowCountChanged = true;\n    }\n    if (updateType === 'U') {\n      // Update will return true if row was within client range\n      if (this.dataWindow.setAtIndex(rowIndex, row)) {\n        this.hasUpdates = true;\n      }\n    }\n  }\n\n  getNewRowCount = () => {\n    if (this.rowCountChanged) {\n      this.rowCountChanged = false;\n      return this.dataWindow.rowCount;\n    }\n  };\n\n  // This is called only after new data has been received from server - data\n  // returned direcly from buffer does not use this.\n  // If we have updates, but we don't yet have data for the full client range\n  // in our buffer, store them in the holding pen. We know the remaining rows\n  // have been requested and will arrive imminently. Soon as we receive data,\n  // contents of holding pen plus additional rows received that fill the range\n  // will be dispatched to client.\n  // If we have any rows in the holding pen, and we now have a full set of\n  // client data, make sure we empty the pen and send those rows to client,\n  // along qith the new data.\n  // TODO what if we're going backwards\n  getClientRows(timeStamp) {\n    if (this.hasUpdates) {\n      const records = this.dataWindow.getData();\n      const { keys } = this;\n      const toClient = this.isTree ? toClientRowTree(this.groupBy, this.columns) : toClientRow;\n\n      // NOte this should probably just check that we havs all client rows within range ?\n      const clientRows = this.dataWindow.hasAllRowsWithinRange\n        ? this.holdingPen.splice(0)\n        : undefined;\n\n      const out = clientRows || this.holdingPen;\n\n      for (let row of records) {\n        if (row && row.ts >= timeStamp) {\n          out.push(toClient(row, keys));\n        }\n      }\n      this.hasUpdates = false;\n\n      // this only matters where we scroll backwards and have holdingPen data\n      // should we test for that explicitly ?\n      return clientRows && clientRows.sort(byRowIndex);\n    }\n  }\n\n  createRequest(params) {\n    return {\n      type: Message.CHANGE_VP,\n      viewPortId: this.serverViewportId,\n      aggregations: this.aggregations,\n      columns: this.columns,\n      sort: this.sort,\n      groupBy: this.groupBy,\n      filterSpec: this.filterSpec,\n      ...params\n    };\n  }\n}\n\nconst toClientRow = ({ rowIndex, rowKey, sel: isSelected, data }, keys) =>\n  [rowIndex, keys.keyFor(rowIndex), true, null, null, 1, rowKey, isSelected].concat(data);\n\nconst toClientRowTree =\n  (groupBy, columns) =>\n  ({ rowIndex, rowKey, sel: isSelected, data }, keys) => {\n    let [depth, isExpanded /* path */, , isLeaf /* label */, , count, ...rest] = data;\n\n    // TODO do we need this - the data is already there\n    const steps = rowKey.split('|').slice(1);\n    groupBy.forEach((col, i) => {\n      const idx = columns.indexOf(col);\n      rest[idx] = steps[i];\n    });\n\n    const record = [\n      rowIndex,\n      keys.keyFor(rowIndex),\n      isLeaf,\n      isExpanded,\n      depth,\n      count,\n      rowKey,\n      isSelected\n    ].concat(rest);\n\n    return record;\n  };\n", "export const getRpcService = (method) => {\n  switch (method) {\n    case 'getUniqueFieldValues':\n      return ['TypeAheadRpcHandler', 'TYPEAHEAD'];\n    default:\n      return ['OrderEntryRpcHandler', 'SIMUL'];\n  }\n};\n", "import * as Message from './messages';\nimport { authRequest, getViewportMenus, getVisualLinks, loginRequest } from './messages';\nimport { Viewport } from './new-viewport';\nimport { getRpcService } from './rpc-services';\nimport {\n  PostMessageFn, SendOptions,\n  ServerConnection,\n  VuuMessage\n} from \"../viewserver/server-proxy\";\n\n// TEST_DATA_COLLECTION\n// import { saveTestData } from '../../test-data-collection';\n\nlet _requestId: number = 1;\nexport const TEST_setRequestId = (id: number) => (_requestId = id);\n\nconst nextRequestId = () => `${_requestId++}`;\nconst EMPTY_ARRAY = [];\nconst DEFAULT_OPTIONS = {};\n\nconst MENU_RPC_CALLS = {\n  'selected-rows': 'VIEW_PORT_MENUS_SELECT_RPC'\n};\n\ninterface PendingAuthentication {\n  resolve: (value: any) => void; // TODO\n  reject: () => void;\n}\n\ninterface PendingLogin {\n  resolve: (value: any) => void; // TODO\n  reject: () => void;\n}\n\nexport class ServerProxy {\n  private connection: ServerConnection;\n  private postMessageToClient: PostMessageFn;\n  private viewports: Map<string, Viewport>;\n  private mapClientToServerViewport: Map<string, string>;\n  private currentTimestamp: any;\n  private pendingAuthentication: PendingAuthentication;\n  private loginToken: string;\n  private pendingLogin: PendingLogin;\n  private sessionId: string;\n  // TODO this wasn't initialised\n  private queuedRequests: VuuMessage[] = [];\n\n  constructor(connection: ServerConnection, callback: PostMessageFn) {\n    this.connection = connection;\n    this.postMessageToClient = callback;\n    this.viewports = new Map();\n    this.mapClientToServerViewport = new Map();\n    this.currentTimestamp = undefined;\n  }\n\n  public async authenticate(username: string, password: string) {\n    return new Promise((resolve, reject) => {\n      this.sendMessageToServer(authRequest(username, password), '');\n      this.pendingAuthentication = { resolve, reject };\n    });\n  }\n\n  public async login(token: string = this.loginToken) {\n    return new Promise((resolve, reject) => {\n      this.sendMessageToServer(loginRequest(token, 'user'), '');\n      this.pendingLogin = { resolve, reject };\n    });\n  }\n\n  public subscribe(message) {\n    // guard against subscribe message when a viewport is already subscribed\n    if (!this.mapClientToServerViewport.has(message.viewport)) {\n      const viewport = new Viewport(message);\n      this.viewports.set(message.viewport, viewport);\n      // use client side viewport as request id, so that when we process the response,\n      // with the serverside viewport we can establish a mapping between the two\n      const isReady = this.sessionId !== '';\n      this.sendIfReady(viewport.subscribe(), message.viewport, isReady);\n    } else {\n      console.log(`ServerProxy spurious subscribe call ${message.viewport}`);\n    }\n  }\n\n  public unsubscribe(clientViewportId: string) {\n    const serverViewportId = this.mapClientToServerViewport.get(clientViewportId);\n    this.sendMessageToServer({\n      type: Message.REMOVE_VP,\n      viewPortId: serverViewportId\n    });\n  }\n\n  public handleMessageFromClient(message: VuuMessage) {\n    const { type, viewport: clientViewportId } = message;\n    const serverViewportId = this.mapClientToServerViewport.get(clientViewportId);\n\n    // TEST DATA COLLECTION\n    // saveTestData(message, 'client');\n    //---------------------\n    const viewport = this.viewports.get(serverViewportId);\n    if (!viewport) {\n      switch (type) {\n        case Message.GET_TABLE_LIST:\n          this.sendMessageToServer({ type }, message.requestId);\n          break;\n        case Message.GET_TABLE_META:\n          this.sendMessageToServer({ type, table: message.table }, message.requestId);\n          break;\n        case Message.RPC_CALL:\n          {\n            // below duplicated - tidy up\n            const { method } = message;\n            const [service, module] = getRpcService(method);\n            this.sendMessageToServer(\n              {\n                type,\n                service,\n                method,\n                params: message.params || [viewport.serverViewportId],\n                namedParams: {}\n              },\n              message.requestId,\n              { module }\n            );\n          }\n          break;\n\n        default:\n      }\n      return;\n    }\n    const isReady = viewport.status === 'subscribed';\n\n    switch (message.type) {\n      case 'setViewRange':\n        {\n          // onsole.log(`%c[serverProxy] setViewRange ${message.range.lo} ${message.range.hi}`,'color:brown;')\n          const requestId = nextRequestId();\n          const [serverRequest, rows] = viewport.rangeRequest(\n            requestId,\n            message.range.lo,\n            message.range.hi\n          );\n          if (serverRequest) {\n            this.sendIfReady(serverRequest, requestId, isReady);\n          }\n          if (rows) {\n            const clientMessage = {\n              type: 'viewport-updates',\n              viewports: {\n                [viewport.clientViewportId]: { rows }\n              }\n            };\n            this.postMessageToClient(clientMessage);\n          }\n        }\n        break;\n\n      case 'aggregate':\n        {\n          const requestId = nextRequestId();\n          const request = viewport.aggregateRequest(requestId, message.aggregations);\n          this.sendIfReady(request, requestId, isReady);\n        }\n        break;\n\n      case 'sort':\n        {\n          const requestId = nextRequestId();\n          const request = viewport.sortRequest(requestId, message.sortCriteria);\n          this.sendIfReady(request, requestId, isReady);\n        }\n        break;\n\n      case 'groupBy':\n        {\n          const requestId = nextRequestId();\n          const request = viewport.groupByRequest(requestId, message.groupBy);\n          this.sendIfReady(request, requestId, isReady);\n        }\n        break;\n\n      case 'filterQuery':\n        {\n          const requestId = nextRequestId();\n          const { filter, filterQuery } = message;\n          const request = viewport.filterRequest(requestId, filter, filterQuery);\n          this.sendIfReady(request, requestId, isReady);\n        }\n        break;\n\n      case 'select':\n        {\n          const requestId = nextRequestId();\n          const { selected } = message;\n          const request = viewport.selectRequest(requestId, selected);\n          this.sendIfReady(request, requestId, isReady);\n        }\n        break;\n\n      case 'suspend':\n        viewport.suspend();\n        break;\n\n      case 'resume':\n        {\n          const rows = viewport.resume();\n          const clientMessage = {\n            type: 'viewport-updates',\n            viewports: {\n              [viewport.clientViewportId]: { rows }\n            }\n          };\n          this.postMessageToClient(clientMessage);\n        }\n        break;\n      case 'disable':\n        {\n          // onsole.log(`%cDISABLE`, 'color:red;font-weight: bold;');\n          const requestId = nextRequestId();\n          const request = viewport.disable(requestId);\n          this.sendIfReady(request, requestId, isReady);\n        }\n        break;\n\n      case 'enable':\n        {\n          const requestId = nextRequestId();\n          const request = viewport.enable(requestId);\n          this.sendIfReady(request, requestId, isReady);\n        }\n        break;\n\n      case 'openTreeNode':\n        this.sendIfReady(\n          {\n            type: Message.OPEN_TREE_NODE,\n            vpId: viewport.serverViewportId,\n            treeKey: message.key\n          },\n          _requestId++,\n          isReady\n        );\n        break;\n\n      case 'closeTreeNode':\n        this.sendIfReady(\n          {\n            type: Message.CLOSE_TREE_NODE,\n            vpId: viewport.serverViewportId,\n            treeKey: message.key\n          },\n          _requestId++,\n          isReady\n        );\n\n        break;\n\n      case 'createLink':\n        {\n          const {\n            parentVpId,\n            parentColumnName,\n            childColumnName,\n            viewport: clientViewportId\n          } = message;\n\n          const serverViewportId = this.mapClientToServerViewport.get(clientViewportId);\n          const viewport = this.viewports.get(serverViewportId);\n          const requestId = nextRequestId();\n          const request = viewport.createLink(\n            requestId,\n            childColumnName,\n            parentVpId,\n            parentColumnName\n          );\n\n          this.sendMessageToServer(request, requestId);\n        }\n        break;\n\n      case Message.MENU_RPC_CALL:\n        {\n          const { context, rpcName } = message;\n          this.sendMessageToServer(\n            {\n              type: MENU_RPC_CALLS[context],\n              rpcName,\n              vpId: viewport.serverViewportId\n            },\n            message.requestId,\n            'CORE'\n          );\n        }\n\n        break;\n\n      case Message.RPC_CALL:\n        {\n          const { method } = message;\n          const [service, module] = getRpcService(method);\n          this.sendMessageToServer(\n            {\n              type,\n              service,\n              method,\n              params: message.params || [viewport.serverViewportId],\n              namedParams: {}\n            },\n            message.requestId,\n            module\n          );\n        }\n\n        break;\n\n      default:\n        console.log(`Vuu ServerProxy Unexpected message from client ${JSON.stringify(message)}`);\n    }\n  }\n\n  public sendIfReady(message: VuuMessage, requestId: string, isReady: boolean = true, options?: any) {\n    // TODO implement the message queuing in remote data view\n    if (isReady) {\n      this.sendMessageToServer(message, requestId, options);\n    } else {\n      // TODO need to make sure we keep the requestId\n      this.queuedRequests.push(message);\n    }\n    return isReady;\n  }\n\n  public sendMessageToServer(\n    body: any,\n    requestId: string = `${_requestId++}`,\n    options: SendOptions = DEFAULT_OPTIONS\n  ) {\n    const { module = 'CORE', ...restOptions } = options;\n    // const { clientId } = this.connection;\n    this.connection.send(\n      {\n        requestId,\n        sessionId: this.sessionId,\n        token: this.loginToken,\n        user: 'user',\n        module,\n        body\n      },\n      restOptions\n    );\n  }\n\n  public handleMessageFromServer(message: VuuMessage) {\n    const {\n      requestId,\n      body: { type, timeStamp, ...body }\n    } = message;\n\n    // onsole.log(`%c<<< [${new Date().toISOString().slice(11,23)}]  (ServerProxy) ${message.type || JSON.stringify(message)}`,'color:white;background-color:blue;font-weight:bold;');\n\n    const { viewports } = this;\n    switch (type) {\n      case Message.HB:\n        this.sendMessageToServer({ type: Message.HB_RESP, ts: +new Date() }, 'NA');\n        break;\n\n      // TODO should be handle these more as Request/Response calls, so we handle the response\n      // at the call site ?\n      case Message.AUTH_SUCCESS:\n        this.loginToken = message.token;\n        this.pendingAuthentication.resolve(message.token);\n        break;\n\n      case Message.LOGIN_SUCCESS:\n        this.sessionId = message.sessionId;\n        this.pendingLogin.resolve(message.sessionId);\n        break;\n\n      case Message.CREATE_VP_SUCCESS:\n        // The clientViewportId was used as requestId for CREATE_VPmessage\n        if (viewports.has(requestId)) {\n          const viewport = viewports.get(requestId);\n          const { viewPortId: serverViewportId } = body;\n\n          if (requestId !== serverViewportId) {\n            viewports.delete(requestId);\n            viewports.set(serverViewportId, viewport);\n          }\n          this.mapClientToServerViewport.set(requestId, serverViewportId);\n          const response = viewport.handleSubscribed(body);\n          if (response) {\n            this.postMessageToClient(response);\n          }\n          this.sendMessageToServer(getVisualLinks(serverViewportId));\n          this.sendMessageToServer(getViewportMenus(serverViewportId));\n        }\n        break;\n\n      case Message.REMOVE_VP_SUCCESS:\n        if (viewports.has(body.viewPortId)) {\n          // do we need a destroy method on viewport for cleanup ?\n          const { clientViewportId } = viewports.get(body.viewPortId);\n          this.mapClientToServerViewport.delete(clientViewportId);\n          viewports.delete(body.viewPortId);\n        }\n        break;\n\n      case Message.SET_SELECTION_SUCCESS:\n        if (viewports.has(body.vpId)) {\n          viewports.get(body.vpId).completeOperation(requestId);\n        }\n        break;\n\n      case Message.CHANGE_VP_SUCCESS:\n      case Message.DISABLE_VP_SUCCESS:\n        if (viewports.has(body.viewPortId)) {\n          const response = this.viewports.get(body.viewPortId).completeOperation(requestId);\n          if (response) {\n            this.postMessageToClient(response);\n          }\n        }\n\n        break;\n\n      case Message.ENABLE_VP_SUCCESS:\n        if (viewports.has(body.viewPortId)) {\n          const viewport = viewports.get(body.viewPortId);\n          const response = viewport.completeOperation(requestId);\n          this.postMessageToClient(response);\n          const rows = viewport.currentData();\n          const clientMessage = {\n            type: 'viewport-updates',\n            viewports: {\n              [viewport.clientViewportId]: { rows }\n            }\n          };\n          this.postMessageToClient(clientMessage);\n        }\n        break;\n      case Message.TABLE_ROW:\n        {\n          const [{ ts: firstBatchTimestamp } = { ts: timeStamp }] = body.rows || EMPTY_ARRAY;\n          // onsole.log(`\\nbatch timestamp ${time(timeStamp)} first timestamp ${time(firstBatchTimestamp)} ${body.rows.length} rows in batch`)\n          for (const row of body.rows) {\n            const { viewPortId, rowIndex, rowKey, updateType } = row;\n            const viewport = viewports.get(viewPortId);\n            if (viewport) {\n              // onsole.log(`row timestamp ${time(row.ts)}`)\n              // This might miss rows if we receive rows after submitting a groupByRequest but before\n              // receiving the ACK\n              if (viewport.isTree && updateType === 'U' && !rowKey.startsWith('$root')) {\n                console.log('Ignore blank rows sent after GroupBy');\n              } else {\n                viewport.handleUpdate(updateType, rowIndex, row);\n              }\n            } else {\n              console.warn(`TABLE_ROW message received for non registered viewport ${viewPortId}`);\n            }\n            // onsole.log(`%c[ServerProxy] after updates, movingWindow has ${viewport.dataWindow.internalData.length} records`,'color:brown')\n          }\n\n          this.processUpdates(firstBatchTimestamp);\n        }\n        break;\n\n      case Message.CHANGE_VP_RANGE_SUCCESS:\n        {\n          const { viewPortId, from, to } = body;\n          viewports.get(viewPortId).completeOperation(requestId, from, to);\n        }\n        break;\n\n      case Message.OPEN_TREE_SUCCESS:\n      case Message.CLOSE_TREE_SUCCESS:\n        break;\n\n      case Message.CREATE_VISUAL_LINK_SUCCESS:\n        {\n          const { childVpId, childColumnName, parentVpId, parentColumnName } = body;\n          const { clientViewportId: parentViewportId } = this.viewports.get(parentVpId);\n          const response = this.viewports\n            .get(childVpId)\n            .completeOperation(requestId, childColumnName, parentViewportId, parentColumnName);\n          if (response) {\n            this.postMessageToClient(response);\n          }\n        }\n        break;\n\n      case Message.TABLE_LIST_RESP:\n        this.postMessageToClient({ type, tables: body.tables, requestId });\n        break;\n\n      case Message.TABLE_META_RESP:\n        this.postMessageToClient({\n          type,\n          table: body.table,\n          columns: body.columns,\n          dataTypes: body.dataTypes,\n          requestId\n        });\n        break;\n\n      case Message.VP_VISUAL_LINKS_RESP:\n        {\n          const links = this.getActiveLinks(body.links);\n          if (links.length) {\n            const viewport = this.viewports.get(body.vpId);\n            const [clientMessage, pendingLink] = viewport.setLinks(links);\n            this.postMessageToClient(clientMessage);\n            if (pendingLink) {\n              console.log({ pendingLink });\n              const { colName, parentViewportId, parentColName } = pendingLink;\n              const requestId = nextRequestId();\n              const serverViewportId = this.mapClientToServerViewport.get(parentViewportId);\n              const message = viewport.createLink(\n                requestId,\n                colName,\n                serverViewportId,\n                parentColName\n              );\n              this.sendMessageToServer(message, requestId);\n            }\n          }\n        }\n        break;\n\n      case Message.VIEW_PORT_MENUS_RESP:\n        if (body.menu.name) {\n          const viewport = this.viewports.get(body.vpId);\n          const clientMessage = viewport.setMenu(body.menu);\n          this.postMessageToClient(clientMessage);\n        }\n        break;\n\n      case Message.VIEW_PORT_MENU_RESP:\n        {\n          const { action } = body;\n          this.postMessageToClient({\n            type,\n            action,\n            tableAlreadyOpen: this.isTableOpen(action.table),\n            requestId\n          });\n        }\n        break;\n\n      case Message.RPC_RESP:\n        {\n          const { method, result } = body;\n          // check to see if the orderEntry is already open on the page\n          this.postMessageToClient({\n            type,\n            method,\n            result,\n            requestId\n          });\n        }\n        break;\n\n      case 'ERROR':\n        console.error(body.msg);\n        break;\n\n      default:\n        console.log(`handleMessageFromServer,${body.type}.`);\n    }\n  }\n\n  isTableOpen(table) {\n    if (table) {\n      const tableName = table.table;\n      for (let viewport of this.viewports.values()) {\n        if (!viewport.suspended && viewport.table === tableName) {\n          return true;\n        }\n      }\n    }\n  }\n\n  // Eliminate links to suspended viewports\n  getActiveLinks(links) {\n    return links.filter((link) => {\n      const viewport = this.viewports.get(link.parentVpId);\n      return viewport && !viewport.suspended;\n    });\n  }\n\n  processUpdates(timeStamp) {\n    let clientMessage;\n    this.viewports.forEach((viewport) => {\n      if (viewport.hasUpdatesToProcess) {\n        const rows = viewport.getClientRows(timeStamp);\n        const size = viewport.getNewRowCount();\n        if (size !== undefined || rows) {\n          clientMessage = clientMessage || {\n            type: 'viewport-updates',\n            viewports: {}\n          };\n          clientMessage.viewports[viewport.clientViewportId] = { rows, size };\n        }\n      }\n      if (clientMessage) {\n        // const now = performance.now();\n        // if (updateTime){\n        //   onsole.log(`time between updates ${now - updateTime}`)\n        // }\n        // updateTime = now;\n        // Object.values(clientMessage.viewports).forEach(({rows, size}) =>\n        //   onsole.log(`%c[ServerProxy] processUpdates, posting ${rows.length} rows (size ${size})`,'color:brown')\n        // )\n        this.postMessageToClient(clientMessage);\n      }\n    });\n  }\n}\n", "import connectWebsocket from '@vuu-ui/data-remote/src/remote-websocket-connection';\nimport connectDataStore from '@vuu-ui/data-store/src/data-store-connection';\n// TEST DATA COLLECTION\nimport { getTestMessages } from '@vuu-ui/data-remote/src/test-data-collection';\nimport { ServerProxy } from '@vuu-ui/data-remote/src/servers/vuu/new-server-proxy';\n\nlet server;\n\nasync function connectToServer(url, token, useWebsocket, onConnectionStatusChange) {\n  const makeConnection = useWebsocket ? connectWebsocket : connectDataStore;\n  const connection = await makeConnection(\n    url,\n    // if this was called during connect, we would get a ReferenceError, but it will\n    // never be called until subscriptions have been made, so this is safe.\n    (msg) =>\n      msg.type === 'connection-status'\n        ? onConnectionStatusChange(msg)\n        : server.handleMessageFromServer(msg)\n  );\n  server = new ServerProxy(connection, (msg) => sendMessageToClient(msg));\n  // TODO handle authentication, login\n  if (!token && connection.requiresAuthentication) {\n    await server.authenticate('bill', 'pword');\n  }\n  if (connection.requiresLogin) {\n    await server.login(token);\n  }\n}\n\nlet lastTime = 0;\nconst timings = [];\n\nfunction sendMessageToClient(message) {\n  const now = Math.round(performance.now());\n  if (lastTime) {\n    timings.push(now - lastTime);\n\n    // if (timings.length % 100 === 0){\n    //   console.log(timings.join(', : '))\n    //   timings.length = 0;\n    // }\n  }\n  postMessage(message);\n  lastTime = now;\n}\n\nconst handleMessageFromClient = async ({ data: message }) => {\n  switch (message.type) {\n    case 'connect':\n      await connectToServer(message.url, message.token, message.useWebsocket, postMessage);\n      postMessage({ type: 'connected' });\n      break;\n    case 'subscribe':\n      server.subscribe(message);\n      break;\n    case 'unsubscribe':\n      server.unsubscribe(message.viewport);\n      break;\n    // TEST DATA COLLECTION\n    case 'send-websocket-data':\n      postMessage({ type: 'websocket-data', data: getTestMessages() });\n      break;\n    default:\n      server.handleMessageFromClient(message);\n  }\n};\n\n/* eslint-disable-next-line no-restricted-globals */\nself.addEventListener('message', handleMessageFromClient);\n\npostMessage({ type: 'ready' });\n"],
  "mappings": "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",
  "names": []
}
