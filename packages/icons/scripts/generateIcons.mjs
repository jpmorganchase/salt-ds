import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { Biome } from "@biomejs/js-api/nodejs";
import glob from "glob";
import { parse } from "jsonc-parser";
import Mustache from "mustache";
import { optimize } from "svgo";
import { svgAttributeMap } from "./svgAttributeMap.mjs";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const biomeConfigPath = path.join(__dirname, "../../../biome.jsonc");
const biomeConfig = parse(await fs.promises.readFile(biomeConfigPath, "utf8"));

const biome = new Biome();
const project = biome.openProject();

biome.applyConfiguration(project.projectKey, {
  formatter: biomeConfig.formatter,
  assist: biomeConfig.assist,
});

const GENERATED_WARNING_COMMENT =
  "// WARNING: This file was generated by a script. Do not modify it manually\n\n";
const CSS_GENERATED_WARNING_COMMENT =
  "/** WARNING: This file includes all icons in a css mask format and was generated by a script. Do not modify it manually */\n\n";

/**
 * Change kebab casing to Pascal casing
 *
 * @param {string} str
 * */
function pascalCase(str) {
  const arr = str.split("-");
  const capital = arr.map(
    (item) =>
      item.charAt(0).toLocaleUpperCase("en-US") +
      item.slice(1).toLocaleLowerCase("en-US"),
  );

  return capital.join("");
}

/**
 * Turn `AppleBanana` into `Apple Banana`
 * @param {string} str
 **/
function breakPascalCasingWithSpace(str) {
  if (str) {
    return str.charAt(0) + str.slice(1).replaceAll(/([A-Z])/g, " $1");
  }
  return str;
}

/**
 * Trying to sort like Biome organize imports rules.
 * e.g. `BuildReportIcon` should come before `BuildingIcon`.
 *
 * Intl.Collator numeric option works for `Forward5Icon` before `Forward10Icon`, like Biome do...
 *
 * https://github.com/biomejs/biome/blob/main/crates/biome_js_analyze/src/assists/source/organize_imports/util.rs
 *
 * @param {string} a
 * @param {string} b
 * */

const collator = new Intl.Collator([], { numeric: true });
function importSortPredicate(a, b) {
  return collator.compare(
    breakPascalCasingWithSpace(a),
    breakPascalCasingWithSpace(b),
  );
}

/** Generate all icon SVG as background image, in a single CSS */
const generateCssAsBg = ({ basePath, cssOutputPath, fileArg }) => {
  // options is optional
  const options = {};

  const globPath = path
    .join(basePath, `./SVG/+(${fileArg})`)
    .replace(/\\/g, "/");

  const fileNames = glob.sync(globPath, options);

  const iconCss = fileNames
    .map((fileName) => {
      const svgString = fs
        .readFileSync(fileName, "utf-8")
        .trim()
        .replaceAll(/\r?\n|\r/g, "");

      const { componentName } = getIconMetadataFromFileName(fileName);

      return `.saltIcons-${componentName}{mask-image:url("data:image/svg+xml,${encodeURIComponent(
        svgString,
      )}");-webkit-mask-image:url("data:image/svg+xml,${encodeURIComponent(
        svgString,
      )}");}`;
    })
    .join("\n");

  const ALL_CSS = `[class*=' saltIcons-'],[class^='saltIcons-'] {mask-size: cover;-webkit-mask-size: cover;background-color: currentColor;
  height:max(var(--salt-size-icon, 12px), 12px);width:max(var(--salt-size-icon, 12px), 12px);}\n`;

  const formattedResult = biome.formatContent(
    project.projectKey,
    CSS_GENERATED_WARNING_COMMENT.concat(ALL_CSS, iconCss),
    { filePath: cssOutputPath },
  );

  fs.writeFileSync(cssOutputPath, formattedResult.content, {
    encoding: "utf8",
  });
};

const DEPRECATED_ICONS = [
  ["Success", "Checkmark"],
  ["SuccessSolid", "CheckmarkSolid"],
  ["SuccessTick", "Checkmark"],
  ["StepSuccess", "SuccessCircle"],
  ["SuccessSmall", "Checkmark"],
  ["SuccessSmallSolid", "CheckmarkSolid"],
];
const deprecatedIconMap = new Map(DEPRECATED_ICONS);

function getIconMetadataFromFileName(fileName) {
  const filenameWithoutExtension = path.parse(fileName).name;
  const parts = filenameWithoutExtension.split("_");

  const componentName = pascalCase(parts.join("-"));

  return {
    componentName,
    iconTitle: parts.join(" ").replaceAll("-", " "),
  };
}

/**
 * Generate all the icon React components from SVGs
 */
const generateIconComponents = async ({
  templatePath,
  basePath,
  componentsPath,
  fileArg,
}) => {
  // options is optional
  const options = {};

  const template = await fs.promises.readFile(templatePath, "utf-8");
  const globPath = path
    .join(basePath, `./SVG/+(${fileArg})`)
    .replace(/\\/g, "/");

  const fileNames = glob.sync(globPath, options);

  return Promise.all(
    fileNames.map(async (fileName) => {
      const svgString = await fs.promises.readFile(fileName, "utf-8");

      const { componentName, iconTitle } =
        getIconMetadataFromFileName(fileName);
      let viewBox;
      const newFilePath = path.join(componentsPath, `${componentName}.tsx`);

      console.log("processing", fileName, "to", newFilePath);

      // SVGO is a separate step to enable multi-pass optimizations.
      const optimizedSvg = optimize(svgString, {
        multipass: true,
        plugins: [
          {
            name: "preset-default",
          },
          {
            name: "removeAttrs",
            params: {
              attrs: "(fill|width|height)",
            },
          },
        ],
      });

      const svgPaths = optimize(optimizedSvg.data, {
        plugins: [
          {
            name: "mapHTMLAttributesToReactProps",
            fn: () => {
              return {
                element: {
                  enter: (node) => {
                    const newAttributes = {};
                    // preserve an order of attributes
                    for (const [name, value] of Object.entries(
                      node.attributes,
                    )) {
                      newAttributes[svgAttributeMap[name] || name] = value;
                    }
                    node.attributes = newAttributes;
                  },
                },
              };
            },
          },

          {
            name: "find-viewBox",
            fn: () => {
              return {
                element: {
                  enter: (node, parentNode) => {
                    if (parentNode.type === "root") {
                      viewBox = node.attributes.viewBox;
                    }
                  },
                },
              };
            },
          },
          {
            name: "removeSvg",
            fn: () => {
              return {
                element: {
                  exit: (node, parentNode) => {
                    if (node.name === "svg") {
                      const index = parentNode.children.indexOf(node);
                      parentNode.children.splice(index, 1, ...node.children);
                    }
                  },
                },
              };
            },
          },
        ],
      });

      const fileContents = Mustache.render(template, {
        svgElements: svgPaths.data,
        componentName,
        ariaLabel: iconTitle,
        viewBox: viewBox ?? "0 0 12 12",
        // note: triple mustache is used here for unescaped version
        JSDoc: deprecatedIconMap.has(componentName)
          ? `
/** @deprecated - Use \`${deprecatedIconMap.get(componentName)}Icon\` instead. */`
          : "",
      });

      const formattedResult = biome.formatContent(
        project.projectKey,
        GENERATED_WARNING_COMMENT.concat(fileContents),
        { filePath: newFilePath },
      );

      await fs.promises.writeFile(newFilePath, formattedResult.content, {
        encoding: "utf8",
      });

      return componentName;
    }),
  );
};

/**
 * Generate the index file to export all Icon components
 */
const generateIndex = async ({ icons, componentsPath }) => {
  console.log("Generating index file");

  const content = icons.sort(importSortPredicate).map((componentName) => {
    return `export * from './${componentName}';`;
  });

  const joinedText = [GENERATED_WARNING_COMMENT, ...content].join("\n");

  const outputFile = path.join(componentsPath, "index.ts");

  const formattedResult = biome.formatContent(project.projectKey, joinedText, {
    filePath: outputFile,
  });

  console.log("creating index at:", outputFile);

  await fs.promises.writeFile(outputFile, formattedResult.content, {
    encoding: "utf8",
  });
};

/**
 * Generate a file to export all Icon components in an array.
 */
const generateIconAll = async ({ icons, allPath }) => {
  console.log(`Generating ${allPath}`);

  const sortedIcons = icons
    .map((componentName) => `${componentName}Icon,`)
    .sort(importSortPredicate)
    .join("\n");

  const importsStatements = `import {\n${sortedIcons}\n} from "@salt-ds/icons";\n`;
  const exportStatements = `export const allIcons = [${sortedIcons}\n];\n`;

  const joinedText = [
    GENERATED_WARNING_COMMENT,
    importsStatements,
    exportStatements,
  ].join("\n");

  const formattedResult = biome.formatContent(project.projectKey, joinedText, {
    filePath: allPath,
  });

  console.log(`Writing ${allPath}`);

  await fs.promises.writeFile(allPath, formattedResult.content, {
    encoding: "utf8",
  });
};

/**
 * Generate a file to export all Icon components in an object.
 */
const generateIconAllSite = async ({ icons, siteAllPath }) => {
  console.log(`Generating ${siteAllPath}`);

  const sortedIcons = icons
    .map((componentName) => `${componentName}Icon,`)
    .sort(importSortPredicate)
    .join("\n");

  const importsStatements = `import {\n${sortedIcons}\n} from "@salt-ds/icons";\n`;
  const exportStatements = `export const allIcons = {${sortedIcons}\n};\n`;

  const joinedText = [
    GENERATED_WARNING_COMMENT,
    importsStatements,
    exportStatements,
  ].join("\n");

  const formattedResult = biome.formatContent(project.projectKey, joinedText, {
    filePath: siteAllPath,
  });

  console.log(`Writing ${siteAllPath}`);

  await fs.promises.writeFile(siteAllPath, formattedResult.content, {
    encoding: "utf8",
  });
};

// Run the script
const basePath = path.join(__dirname, "../src");
const componentsPath = path.join(basePath, "./components/");
const cssOutputPath = path.join(__dirname, "../saltIcons.css");
const fileArg = process.argv.splice(2).join("|");
const templatePath = path.join(__dirname, "./templateIcon.mustache");
const allPath = path.join(basePath, "../stories/icon.all.ts");
const siteAllPath = path.join(
  basePath,
  "../../../site/src/components/icon-preview/allIconsList.ts",
);

await fs.promises.mkdir(componentsPath, { recursive: true });
const icons = await generateIconComponents({
  templatePath,
  componentsPath,
  basePath,
  fileArg,
});
await generateCssAsBg({ basePath, cssOutputPath, fileArg });
await generateIndex({ icons, componentsPath });
await generateIconAll({ icons, allPath });
await generateIconAllSite({ icons, siteAllPath });
