import fs from "node:fs/promises";
import path from "node:path";
import glob from "glob";
import prettier from "prettier";
import Mustache from "mustache";
import { optimize } from "svgo";
import { fileURLToPath } from "node:url";
import { svgAttributeMap } from "./svgAttributeMap.mjs";

const PRETTIER_SETTINGS = {
  parser: "typescript",
  useTabs: false,
  tabWidth: 2,
  printWidth: 80,
  endOfLine: "lf",
};

const GENERATED_WARNING_COMMENT =
  "// WARNING: This file was generated by a script. Do not modify it manually\n";

/** Change kebab casing to Pascal casing */
function pascalCase(str) {
  let arr = str.split("-");
  let capital = arr.map(
    (item) =>
      item.charAt(0).toLocaleUpperCase("en-US") +
      item.slice(1).toLocaleLowerCase("en-US")
  );

  return capital.join("");
}

/**
 * Generate all the icon React components from SVGs
 */
const generateIconComponents = async ({
  templatePath,
  basePath,
  componentsPath,
}) => {
  const fileArg = process.argv.splice(2).join("|");
  // options is optional
  const options = {};

  const template = await fs.readFile(templatePath, "utf-8");
  const globPath = path
    .join(basePath, `./SVG/+(${fileArg})`)
    .replace(/\\/g, "/");

  const fileNames = glob.sync(globPath, options);

  return await Promise.all(
    fileNames.map(async (fileName) => {
      const svgString = await fs.readFile(fileName, "utf-8");

      const filenameWithoutExtension = path.parse(fileName).name;
      const componentName = pascalCase(filenameWithoutExtension);

      let viewBox;
      const newFilePath = path.join(componentsPath, `${componentName}.tsx`);

      console.log("processing", fileName, "to", newFilePath);

      const iconTitle = filenameWithoutExtension
        .split("-")
        .join(" ")
        .toLowerCase();

      // SVGO is a separate step to enable multi-pass optimizations.
      const optimizedSvg = optimize(svgString, {
        multipass: true,
        plugins: [
          {
            name: "preset-default",
            params: {
              overrides: {
                // makes icons scaled into width/height box
                removeViewBox: false,
              },
            },
          },
          {
            name: "removeAttrs",
            params: {
              attrs: "(fill|width|height)",
            },
          },
        ],
      });

      const svgPaths = optimize(optimizedSvg.data, {
        plugins: [
          {
            name: "mapHTMLAttributesToReactProps",
            fn: () => {
              return {
                element: {
                  enter: (node) => {
                    const newAttributes = {};
                    // preserve an order of attributes
                    for (const [name, value] of Object.entries(
                      node.attributes
                    )) {
                      newAttributes[svgAttributeMap[name] || name] = value;
                    }
                    node.attributes = newAttributes;
                  },
                },
              };
            },
          },

          {
            name: "find-viewBox",
            fn: () => {
              return {
                element: {
                  enter: (node, parentNode) => {
                    if (parentNode.type === "root") {
                      viewBox = node.attributes.viewBox;
                    }
                  },
                },
              };
            },
          },
          {
            name: "removeSvg",
            fn: () => {
              return {
                element: {
                  exit: (node, parentNode) => {
                    if (node.name === "svg") {
                      const index = parentNode.children.indexOf(node);
                      parentNode.children.splice(index, 1, ...node.children);
                    }
                  },
                },
              };
            },
          },
        ],
      });

      const fileContents = Mustache.render(template, {
        svgElements: svgPaths.data,
        componentName,
        ariaLabel: iconTitle,
        viewBox: viewBox ?? "0 0 12 12",
      });

      const formattedResult = prettier.format(
        GENERATED_WARNING_COMMENT.concat(fileContents),
        PRETTIER_SETTINGS
      );

      await fs.writeFile(newFilePath, formattedResult, {
        encoding: "utf8",
      });

      return componentName;
    })
  );
};

/**
 * Generate the index file to export all Icon components
 */
const generateIndex = async ({ icons, componentsPath }) => {
  console.log("Generating index file");

  const content = icons
    .sort((a, b) => a.localeCompare(b))
    .map((componentName) => {
      return `export * from './${componentName}';`;
    });

  const joinedText = [GENERATED_WARNING_COMMENT, ...content].join("\n");

  const formattedResult = prettier.format(joinedText, PRETTIER_SETTINGS);

  const outputFile = path.join(componentsPath, "index.ts");

  console.log("creating index at:", outputFile);

  await fs.writeFile(outputFile, formattedResult, { encoding: "utf8" });
};

/**
 * Generate a file to export all Icon components in an array.
 */
const generateIconAll = async ({ icons, allPath }) => {
  console.log(`Generating ${allPath}`);

  const sortedIcons = icons
    .sort((a, b) => a.localeCompare(b))
    .map((componentName) => `${componentName}Icon,`);

  const importsStatements =
    "import {\n" + sortedIcons.join("\n") + `\n} from "@salt-ds/icons";\n`;
  const exportStatements =
    "export const allIcons = [" + sortedIcons.join("\n") + "\n];\n";

  const joinedText = [
    GENERATED_WARNING_COMMENT,
    importsStatements,
    exportStatements,
  ].join("\n");

  const formattedResult = prettier.format(joinedText, PRETTIER_SETTINGS);

  console.log(`Writing ${allPath}`);

  await fs.writeFile(allPath, formattedResult, { encoding: "utf8" });
};

// Run the script
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const basePath = path.join(__dirname, "../src");
const componentsPath = path.join(basePath, "./components/");
const templatePath = path.join(__dirname, "./templateIcon.mustache");
const allPath = path.join(basePath, "../stories/icon.all.ts");

await fs.mkdir(componentsPath, { recursive: true });
const icons = await generateIconComponents({
  templatePath,
  componentsPath,
  basePath,
});
await generateIndex({ icons, componentsPath });
await generateIconAll({ icons, allPath });
